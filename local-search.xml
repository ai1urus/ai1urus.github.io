<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用Semantic Scholar检索同时引用多篇特定文章的论文</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>一、python安装semanticscholar包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install semanticscholar<br></code></pre></td></tr></table></figure><p>二、在<a href="https://www.semanticscholar.org/">Semantic Scholar | AI-Powered Research Tool</a>上根据论文名称检索到特定论文，获取对应的索引号</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220826102950707.png" alt="image-20220826102950707"></p><p>三、基于两篇文章的索引号查找共引论文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> semanticscholar <span class="hljs-keyword">as</span> sch<br><br><span class="hljs-comment"># 查找论文 Denoising Diffusion Probabilistic Models</span><br>paper1 = sch.paper(<span class="hljs-string">&#x27;arXiv:2006.11239&#x27;</span>,timeout=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 查找论文 3D U-Net: Learning Dense Volumetric Segmentation from Sparse Annotation</span><br>paper1 = sch.paper(<span class="hljs-string">&#x27;arXiv:2006.11239&#x27;</span>,timeout=<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 注意，当论文被引次数过多时相应会比较慢，如果报超时错误可以将timeout设为更大的值</span><br><br><span class="hljs-comment"># 查看响应内容</span><br>paper1.keys()<br><br>dict_keys([<span class="hljs-string">&#x27;abstract&#x27;</span>, <span class="hljs-string">&#x27;arxivId&#x27;</span>, <span class="hljs-string">&#x27;authors&#x27;</span>, <span class="hljs-string">&#x27;citationVelocity&#x27;</span>, <span class="hljs-string">&#x27;citations&#x27;</span>, <span class="hljs-string">&#x27;corpusId&#x27;</span>, <span class="hljs-string">&#x27;doi&#x27;</span>, <span class="hljs-string">&#x27;fieldsOfStudy&#x27;</span>, <span class="hljs-string">&#x27;influentialCitationCount&#x27;</span>, <span class="hljs-string">&#x27;isOpenAccess&#x27;</span>, <span class="hljs-string">&#x27;isPublisherLicensed&#x27;</span>, <span class="hljs-string">&#x27;is_open_access&#x27;</span>, <span class="hljs-string">&#x27;is_publisher_licensed&#x27;</span>, <span class="hljs-string">&#x27;numCitedBy&#x27;</span>, <span class="hljs-string">&#x27;numCiting&#x27;</span>, <span class="hljs-string">&#x27;paperId&#x27;</span>, <span class="hljs-string">&#x27;references&#x27;</span>, <span class="hljs-string">&#x27;s2FieldsOfStudy&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;topics&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;venue&#x27;</span>, <span class="hljs-string">&#x27;year&#x27;</span>])<br><br><span class="hljs-comment"># 筛选同时引用paper1和paper2的文章</span><br>co_citations = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(x[<span class="hljs-string">&#x27;title&#x27;</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> paper1[<span class="hljs-string">&#x27;citations&#x27;</span>]) &amp; <span class="hljs-built_in">set</span>(x[<span class="hljs-string">&#x27;title&#x27;</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> paper2[<span class="hljs-string">&#x27;citations&#x27;</span>]))<br><br><span class="hljs-comment"># 筛选高影响力结果</span><br>co_citations = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(x[<span class="hljs-string">&#x27;title&#x27;</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> paper1[<span class="hljs-string">&#x27;citations&#x27;</span>] <span class="hljs-keyword">if</span> x[<span class="hljs-string">&#x27;isInfluential&#x27;</span>]) &amp; <span class="hljs-built_in">set</span>(x[<span class="hljs-string">&#x27;title&#x27;</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> paper2[<span class="hljs-string">&#x27;citations&#x27;</span>] <span class="hljs-keyword">if</span> x[<span class="hljs-string">&#x27;isInfluential&#x27;</span>]))<br><br>co_citations = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(x[<span class="hljs-string">&#x27;title&#x27;</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> paper1[<span class="hljs-string">&#x27;citations&#x27;</span>] <span class="hljs-keyword">if</span> x[<span class="hljs-string">&#x27;title&#x27;</span>].find(<span class="hljs-string">&#x27;3D&#x27;</span>)!=-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【操作系统】基础知识汇总</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><p>（1）read + write，2次系统调用，4次上下文切换，4次拷贝</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/D37D6510-CFDF-4EBD-AC94-5EAEC11EB248.png" alt="D37D6510-CFDF-4EBD-AC94-5EAEC11EB248"></p><p>（2）mmap + write，2次系统调用，4次上下文切换，3次拷贝</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/F9D8E70E-0FE5-41B4-8D1B-5704F0B964A8.png" alt="F9D8E70E-0FE5-41B4-8D1B-5704F0B964A8"></p><p>（3）sendfile，1次系统调用，2次上下文切换，3次拷贝</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/20C55D84-5759-42FB-815F-7B5B1C31DCA4.png" alt="20C55D84-5759-42FB-815F-7B5B1C31DCA4"></p><p>（4）sendfile（网卡支持SG-DMA），1次系统调用，2次上下文切换，2次拷贝</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/E362D767-55BB-4FFD-BD23-A5EB4BD9FD12.png" alt="E362D767-55BB-4FFD-BD23-A5EB4BD9FD12"></p><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>内核态就是运行操作系统内核程序，用户态就是运行内核上层的应用程序</p><p>申请外部资源（1）系统调用（2）中断（3）异常</p><p>读写文件：open、read、write</p><p>申请内存（堆）：mmap系统调用，映射内核态内存到用户态内存；brk系统调用，小于等于128K；缺页中断</p><p>系统调用：</p><p>进程控制、fork、exit</p><p>文件管理、chmod、chown、read、write、open</p><p>设备管理、read、write、mmap</p><p>硬件信息获取、get</p><p>通信相关、pipe、mmap</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>共享内存</p><p>pipe</p><p>信号量</p><p>socket</p><p>管道</p><p>匿名管道</p><p>消息队列</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><a href="https://blog.csdn.net/afsvsv/article/details/94553228">原码，反码，补码的深入理解与原理_xiaoxiaoyunlu的博客-CSDN博客_补码反码</a></p><p>原码：符号位1位+表示位n位，存在+0、-0和相同绝对值的正反两数相加不为0的问题</p><p>反码：对于负数，反码等与原码除符号位外全部反转，为了解决+0、-0和相加不为0问题。但负数相加出错。</p><p>补码：为了将-0和+0并起来，将正负数组成一个环。正数从0开始，表示位代表和0相差值。负数从MIN（如-128，1000 0000，原码中表示-0，补码中表示MIN）开始，表示负数到MIN的相差值。首先将正数补码-1，将0对齐到-0，然后按位取反（包括符号位）得到负数补码。</p>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】基础知识汇总</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>————————————————————————————————————————————————————————————</p><p><strong>应用层：为应用程序提供统一接口。</strong></p><p><strong>表示层：将数据格式转化为其他机器可以识别的格式。</strong></p><p><strong>会话层：建立、管理和终止表示层连接实体。</strong></p><p>————————————————————————————————————————————————————————————</p><p><strong>（1）HTTP（TCP）长连接短连接区别</strong></p><ul><li>HTTP1.0只支持短连接，HTTP1.1起支持长连接。</li><li>通过在请求头配置<code>keep-alive:true</code>，返回头响应<code>connection:keep-alive</code>来配置长连接。</li><li>短连接完成一次HTTP请求和响应即关闭；长连接在连接有效期内可完成多次HTTP请求和响应，在请求包含多个资源的网页时可以减少逐个请求的开销。</li><li>短连接保证每个连接都是有效连接；长连接不主动关闭会一直保持连接，而保持多个长连接占用系统连接资源，因此需要通过心跳检测机制确认连接方是否正常，并及时关闭无响应的连接。</li></ul><p><strong>（2）HTTP是什么？有什么特点？报文组成？</strong></p><p>HTTP是在「两点（可以是服务器到服务器）」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p><p>HTTP是无状态的，允许传输任意类型的数据。</p><p>HTTP请求报文包括请求行（域名、请求方法、HTTP 版本）、请求头部（属性列表）、请求体</p><p>HTTP响应报文包括响应行（状态码、状态描述、HTTP 版本）、响应头部（属性列表）、响应体</p><p><strong>（3）HTTP常见状态码？</strong></p><table><thead><tr><th></th><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>1xx</td><td></td><td>协议处理中间状态</td></tr><tr><td>2xx</td><td>200 OK</td><td>请求成功</td></tr><tr><td></td><td>204 No Content</td><td>请求成功但响应头无body</td></tr><tr><td></td><td>206 Partial Content</td><td>请求成功并返回资源的一部分，用于分块下载或断点续传</td></tr><tr><td>3xx</td><td>301 Moved Permanently</td><td>永久重定向，应使用重定向的URL，响应头有Location信息</td></tr><tr><td></td><td>302 Found</td><td>临时重定向，以后仍然需要使用原URL，响应头有Location信息</td></tr><tr><td></td><td>304 Not Modified</td><td>当客户端仅请求指定日期之后的资源，此状态码表示自给定日期后资源无修改，<br />客户端可以继续使用缓存资源</td></tr><tr><td>4xx</td><td>400 Bad Request</td><td>客户端请求出错</td></tr><tr><td></td><td>401 Unauthorized</td><td>客户端必须登录才能执行请求</td></tr><tr><td></td><td>403 Forbidden</td><td>客户端请求的资源被禁止访问</td></tr><tr><td></td><td>404 Not Found</td><td>客户端请求的资源未找到</td></tr><tr><td>5xx</td><td>500 Internal Server Error</td><td>服务器内部出错</td></tr><tr><td></td><td>501 Not Implement</td><td>服务未实现</td></tr><tr><td></td><td>502 Bad Gateway</td><td>网关或代理服务器访问后端服务器异常，得到无效的响应</td></tr><tr><td></td><td>503 Service Unavailable</td><td>服务器过载</td></tr></tbody></table><p><strong>（4）HTTP常见字段？</strong></p><table><thead><tr><th>字段名</th><th>说明</th><th>例</th></tr></thead><tbody><tr><td>Host</td><td>请求：域名</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>Content-Length</td><td>响应：本次回应数据长度</td><td>1000</td></tr><tr><td>Connection</td><td>请求&#x2F;响应：一般用于保持长连接</td><td>Keep-Alive</td></tr><tr><td>Content-Type&#x2F;Accept</td><td>响应&#x2F;请求：指定数据格式</td><td>text&#x2F;html; charset&#x3D;utf-8</td></tr><tr><td>Content-Encoding&#x2F;Accept-Encoding</td><td>响应&#x2F;请求：指定数据压缩格式</td><td>gzip, deflate</td></tr></tbody></table><p><strong>（5）GET与POST区别（功能规范、幂等性要求、请求参数位置）</strong></p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>功能规定</td><td>获取资源</td><td>根据请求处理资源</td></tr><tr><td>是否要求幂等</td><td>是，可以做缓存，可以保存为书签</td><td>否，无法缓存或保存为书签</td></tr><tr><td>请求参数位置</td><td>URL后</td><td>可以在URL后，也可以在请求body中</td></tr></tbody></table><p><strong>（6）HTTP缓存</strong></p><p><strong>强制缓存（浏览器判断）</strong></p><p>二者同时存在时以相对时间为准。当对已有资源再次请求时，浏览器会判断资源是否超时，如果未超时则返回<code>200（from disk cache）</code></p><p>（一）相对时间：响应头添加<code>Cache-Control</code>字段，根据当前请求时间计算超时时间，不依赖于客户端和服务器的时间同步</p><p>（二）绝对时间：响应头添加<code>Expires</code>（服务器时间）字段，当客户端与服务器时间不同步可能产生资源过期问题</p><p><strong>协商缓存（服务器判断）</strong></p><p>二者同时存在时以序列号为准。强制缓存失效时使用协商缓存。当服务器判断资源未过期时返回<code>304 Not Modified</code>且不返回资源，否则按正常请求结果返回状态码及资源。使用时间戳会暴露文件的修改时间信息，所以唯一标识符相对更加可靠。</p><p>（一）时间戳：请求头中加入已有资源修改时间<code>If-Modified-Since</code>，服务器判断修改时间是否变动，响应头中包含<code>Last-Modified</code>。</p><p>（二）序列号：请求头中加入已有资源序列号<code>If-None-Match</code>，服务器判断序列号是否一致，响应头中包含<code>Etag</code>。</p><p><strong>（7）SSL安全证书中存储的什么内容，公钥还是私钥？</strong></p><p>证书所有者公钥、证书信息（所有者名称、CA名称、序列号、版本信息、有效期）、签名算法、CA对证书内容的签名（对证书中所有内容计算摘要哈希值，然后使用私钥加密）</p><p>公钥与私钥是相对的概念，他们都是只能单向加解密的。一般被服务器持有的称为私钥，分发给客户端的称为公钥，所以证书里是公钥。</p><p><strong>（8）http和https的理解，https如何实现安全传输？</strong></p><p>（8.1）http存在三个风险</p><p>（一）窃听风险。明文传输，不能保证用户信息安全</p><p>（二）冒充风险，不确认交流双方身份，不能保证服务器正确</p><p>（三）篡改风险，不能保证信息被篡改</p><p>（8.2）https使用非对称加密（加密对称密钥）和对称加密（加密HTTP报文）的混合加密机制解决了这个问题</p><p>公钥加密，私钥解密保证了信息安全。</p><p>私钥加密，公钥解密保证了身份不会被冒充。</p><p>（一）信息加密，通过对称密钥加密HTTP报文，避免明文传输</p><p>（二）身份证书，通过CA证书确认服务器身份正确</p><p>（三）校验机制，通过报文加密防止信息被篡改</p><p>（8.3）SSL&#x2F;TLS1.2连接建立过程</p><p>（一）Server从CA获取证书</p><p>（二）ClientHello，包括（1）支持的SSL&#x2F;TLS版本（2）支持的密码套件列表如RSA（3）一个随机数（Client Random）</p><p>（三）ServerHello，包括（1）确认SSL&#x2F;TLS版本（2）确认密码套件列表（3）一个随机数（Server Random）（4）数字证书</p><p>（四）Client回应，根据浏览器内置的CA公钥验证证书有效性。返回（1）一个随机数（pre-master key）（2）加密方式切换通知（后面都适用对称会话密钥加密）（3）握手结束通知（包含当前所有发生内容的信息摘要供服务器校验）</p><p>（五）Client和Server各自使用三个随机数及约定的加密算法生成对称会话密钥</p><p>（六）Server回应，回复（1）加密方式切换通知（2）握手结束通知（包含当前所有发生内容的信息摘要供客户端校验）</p><p>（8.4）为什么需要四次握手？</p><p>TLS1.2客户端需要在第三次握手发送随机key作为RSA密钥的一部分，服务端需要在第四次握手回复确认收到第三次握手的随机key。TLS1.3全面使用椭圆曲线算法，在第一次和第二次握手会发送密钥协商参数（TLS1.2中在第三次握手由客户端发送给服务器），分别为<code>A = a*G、B = b*G</code>，最终的密钥为<code>(a*G)*b</code>或<code>a*(G*b)</code>，无法根据A或B破解整个密钥。</p><p><u>前向安全？快速恢复？</u></p><p><a href="https://blog.csdn.net/zk3326312/article/details/80245756">详解TLS1.3的握手过程_曾柯的博客-CSDN博客_tls1.3</a></p><p><a href="https://blog.csdn.net/weixin_43408952/article/details/124727681">TLS1.2 和 TLS1.3的简要区别_Simple-Easy 化繁为简的博客-CSDN博客_tls1.3和tls1.2</a></p><p><strong>（9）HTTPS会把报文头加密吗</strong></p><p>会。SSL&#x2F;TLS会将HTTP报文整体加密。</p><p><u><strong>（10）HTTP各版本对比</strong>✨✨</u></p><p>HTTP1.0</p><p>缺点：只有短连接</p><p>HTTP1.1</p><p>改进：引入长连接，支持管道传输（连续发送多个请求，不必等待返回响应后再发送）</p><p>缺点：</p><p>（1）请求&#x2F;响应头未压缩，只能压缩Body。</p><p>（2）HTTP Header头部较大且重复。</p><p>（3）服务器按顺序响应，存在队头阻塞。</p><p>（4）没有请求优先级控制，并发连接数有限。</p><p>（5）不支持服务器推送消息。</p><p>HTTP2.0</p><p>改进：</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/stream.png" alt="img"></p><p>（1）直接将HTTP Header和Body存储为二进制，分别定义为Header Frame和Body Frame，可以直接读写二进制（如200不用拆成’2’ ‘0’ ‘0’，而是直接保存200），加快传输速度。帧的类型如下：</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/%E5%B8%A7%E7%B1%BB%E5%9E%8B.png" alt="img"></p><p>（2）引入HPACK算法，在客户端和服务器为高频Header字段建立索引表，包括静态表（统计生成的61个高频字段）、动态表（同一连接传输过程中的完全相同的字段）及霍夫曼编码。</p><p>（3）引入Stream，一条TCP连接拆分为多个Stream，一个Stream中的Request和Response与HTTP&#x2F;1中的概念对应，Message中包含一个或多个Frame，以二进制存放HTTP&#x2F;1报文内容。一个HTTP消息（request response）可以有多个frame，一个frame可以有多个TCP报文，也可以有多个frame在一个tcp报文中。</p><p>（4）多路复用，使用一个TCP连接中的多个Stream实现并发，不同Stream的帧可以乱序发送，但同一个Stream的帧必须有序。通过设置Stream的优先级来实现对不同资源的优先顺序访问。客户端必须是奇数号帧，服务器是偶数号。</p><p>（5）服务器推送（比如返回html时同时返回对应的css）可以使用控制帧中的PUSH_PROMISE发起，组装在response message中。</p><p><a href="https://xiaolincoding.com/network/2_http/http2.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E8%B5%84%E6%BA%90">3.6 HTTP&#x2F;2 牛逼在哪？ | 小林coding</a></p><p>缺点：</p><p>（1）仍存在队头阻塞的问题。运行在TCP上，TCP丢包时整个TCP都要等待重传。</p><p>（2）TCP与TLS本身握手的延时</p><p>（3）网络迁移需要重新连接，TCP根据四元组标识连接</p><p>HTTP3.0</p><p>改进：</p><p>（1）基于UDP实现了QUIC协议，在UDP上建立一套伪TCP连接，UDP不存在队头阻塞。</p><p>（2）自定义了握手流程，同时把TLS连接的建立过程整合在了握手中，避免了连接启动时延。</p><p>（3）使用连接ID标识连接而不是借助TCP的四元组。</p><p>QUIC不依赖于操作系统实现</p><p><strong>（11）浏览器输入url到出现画面的过程</strong></p><p>URL解析、HTTP报文封装、DNS、IP报文封装、MAC报文封装、物理传输、路由、拆包、相同路径返回HTML文件，拆包、解析并显示</p><p><strong>（12）能起一个服务在443端口同时监听TCP和UDP吗？</strong></p><p>可以。同一个端口的TCP和UDP可以分别监听，但同一个端口单独的TCP&#x2F;UDP无法被多个服务监听。</p><p>多个进程舰艇同一个端口只能是一个主进程bind后listen前fork生成子进程。</p><p><a href="https://blog.csdn.net/L13763338360/article/details/106519027">如何多个进程监听同一个端口_L13763338360的博客-CSDN博客_多进程监听同一端口</a></p><p><strong>（13）session和cookie</strong></p><p>服务器生成sessionID，发送给客户端，同时在服务器本地维护一个session保存客户状态。客户端本地使用cookie保存sessionID及会话过程中的状态，发送请求时附上cookie以确认sessionID。Cookie可以长期保存，Session在客户端关闭或超时后失效。Cookie容易被窃取，Session相对安全。</p><p>Session和Cookie交互本质上是用SessionID维护的，如果禁用Cookie可以在Post的body中或者Get的网址后添加SessionID来实现。</p><p>分布式Session，使用缓存中间统一管理用户Session，服务器本身不存储。</p><p><u>跨域请求？</u>chrome浏览器本地不同源，需要假设本地http服务器使用域名访问资源。</p><p>同源&#x3D;协议（http&#x2F;https）+域名（不能是IP）+端口号</p><p><a href="https://www.zhihu.com/question/19786827/answer/28752144">COOKIE和SESSION有什么区别？ - 轩辕志远的回答 - 知乎</a></p><p>（14）聊天应用层协议设计？</p><p>一、使用的网络层、传输层、应用层协议。TCP&#x2F;Websocket维护长连接</p><p>二、UDP</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>————————————————————————————————————————————————————————————</p><p>传输层：提供数据传输服务，屏蔽下层通信子网性能差异。规定数据传输方式及对应的发送和接收策略。TCP、UDP</p><p>————————————————————————————————————————————————————————————</p><p>分流&#x2F;合流：多条数据链路支持一条运输连接上的数据传输</p><p>复用&#x2F;解复用：一条数据链路支持多条数据连接上的传输</p><p>拼接&#x2F;分割：</p><p>分段&#x2F;合段：通过将过长的数据拆分、组合来支持无限长数据的传输，比如说HTTP请求超过一个TCP包的容量，就会拆分成两个或多个包传输，接收端接收后再将其组合</p><p>差错检测和纠错：</p><p>流量控制：</p><p><strong>（1）TCP、UDP区别，各自应用场景，视频流传输用哪个？</strong></p><p>TCP是面向连接的，传输前后要进行连接的建立和断开；面向字节流，确保每一个字节按序到达；有粘包拆包现象；有拥塞控制；提供可靠服务。TCP通过序列号、超时重传、快速重传保证可靠性</p><p>UDP无连接，按最大努力交付；面向报文？不拆分不合并，不会有粘包和拆包；无拥塞控制，可以1对1，1对多，多对多，实时通信。UDP首部较小。</p><p>UDP报文包括源端口、目的端口、包长度、校验和、数据</p><p>TCP报文包括源端口、目的端口、包长度、校验和、数据、<strong>标志位、序列号（保证交付顺序）、确认应答号（用于接收应答）</strong></p><p>TCP保证无损坏、无间隔、非冗余、按序。TCP面向连接（一对一）、可靠（保证交付）、字节流（按序接受，重复丢弃）</p><p>连接、可靠性、服务对象数量、拥塞控制和流量控制、首部长度、传输方式、分片不同（TCP在传输层拆分，UDP在IP层拆分）</p><p><strong>（2）为什么要三次握手</strong></p><p>三次握手主要是为了初始化Socket、窗口大小、序列号</p><p>避免重复历史连接：在网络拥堵或客户端宕机导致SYN包过期时，客户端会判断服务器返回的ACK包是否与本次发送的SYN包对应，如果不对应则为历史连接，发送RST终止。</p><p>同步双方初始序列号：序列号用于唯一标识TCP报文，同时指定其接受顺序。接收方可以去除重复包，发送方可以确定已接收包。三次握手刚好可以保证序列号被两方都接收。</p><p>避免资源浪费：避免了重复连接造成的资源浪费。</p><p>两次握手无法避免重复历史连接，四次握手中的二三步可以合并。</p><p>SYN攻击？</p><p>Linux有SYN半连接队列和Accept全连接队列，收到SYN加入SYN队列，收到ACK则由SYN转入Accept队列。使用accept()接口从Accept队列中取出socket连接。SYN队列满了可以不加入SYN，直接返回？那SYN队列的作用是什么</p><p>（3）为什么需要改变每次连接的初始化序列号？</p><p>首先是避免序列号回绕（使用TCP时间戳判断数据包是否是递增的，但如果是上一个周期后半部分和本周期前半部分的怎么办？）、接收历史报文，其次避免序列号伪造？？</p><p>（3）TCP报文组成</p><p>序列号、源端口、目的端口、ACK确认应答号、控制位（ACK、SYN、FIN、RST）、窗口大小、校验和、紧急指针</p><p>（4）为什么需要TCP协议？</p><p>IP层不可靠，只负责将网络数据包转交，不保证顺序和数据完整性。TCP作用是保证数据包按序、完整、无冗余、无间隔的</p><p>（5）什么是TCP连接？最大连接数？</p><p>TCP连接为Socket四元组、序列号、窗口大小。理论最大连接数为理论最大IP数 <code>2^32</code> 乘以理论最大端口数<code>2^16</code>即 <code>2^48</code> ，但同时也受系统文件描述符限制。</p><p><strong>为什么需要第四次挥手</strong></p><p>ACK不会重传。四次挥手后等待2MSL（往返一次的超时时间），使得本次连接所有报文过期，避免影响后面连接。</p><p>MSL 默认30s，略长于TLL64跳的时间</p><p>TTL 默认64跳</p><p>RTT Round-Trip Time 消息往返一次、两次握手的时间</p><p>RTO Retransmission Time out 重传超时时间，一般比RTT略长</p><p>MTU</p><p>MSS</p><p>（6）TCP重传机制？</p><table><thead><tr><th></th><th>超时重传</th><th>快速重传</th><th>选择性确认</th></tr></thead><tbody><tr><td>触发机制</td><td>RTO定时器到期</td><td>连续3次接收到相同ACK</td><td>连续3次接收到相同ACK</td></tr><tr><td>额外处理机制</td><td>每次RTO到期后置为2*RTO<br />继续等待，最多2次</td><td></td><td>返回ACK时附加SACK，SACK记录在ACK<br />序列好之后已经收到的包的编号</td></tr><tr><td>拥塞控制</td><td>sstresh &#x3D; cwnd&#x2F;2, cwnd &#x3D; 1</td><td>sstresh &#x3D; cwnd&#x2F;2, cwnd &#x3D; sstresh + 3</td><td></td></tr></tbody></table><p>（7）TCP拥塞控制？</p><p>慢启动，指数级增长</p><p>阈值，增长到阈值之后进入拥塞避免，每次增加1&#x2F;cwnd，相当于线性增长</p><p>（8）TCP三次握手流程</p><p>服务端</p><p>S1 创建Socket，返回SocketID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span><br></code></pre></td></tr></table></figure><ul><li>domian：PF_INET、PF_INET6、PF_LOCAL等</li><li>type：SOCK_STREAM(TCP)、SOCK_DGRAM(UDP)、SOCK_RAW（原始SOCKET）</li><li>protocol：废弃</li></ul><p>S2 使用SocketID进行端口绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">bind</span>(<span class="hljs-type">int</span> fd, sockaddr* addr, <span class="hljs-type">socklen_t</span> len)<br><span class="hljs-comment">// 等价于下式，但由于设计之初没有void*，所以使用sockaddr，在使用前转换成目标指针</span><br><span class="hljs-built_in">bind</span>(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span>* addr, <span class="hljs-type">socklen_t</span> len)<br></code></pre></td></tr></table></figure><ul><li>addr：通用地址格式，可以是IPv4、IPv6或Local</li><li>len：传入地址长度，通过地址长度来判断地址格式类型</li></ul><p>S3 开始listen对应端口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> socketfd, <span class="hljs-type">int</span> backlog)</span></span><br></code></pre></td></tr></table></figure><ul><li>backlog：可接受的并发数目，参数越大可并发服务的数量越多</li></ul><p>S4 Accept请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> listensockfd, <span class="hljs-keyword">struct</span> sockaddr *cliaddr, <span class="hljs-type">socklen_t</span> *addrlen)</span></span><br></code></pre></td></tr></table></figure><ul><li>listensockfd：上述服务端socketID</li><li>cliaddr：客户端地址+端口</li><li>addrlen：客户端地址和端口信息长度</li><li>返回值： 新的描述字，代表与服务器与指定客户端的连接ID。服务器与不同客户端连接的描述字不同。</li></ul><p>客户端</p><p>S1 创建Socket，获取SocketID（同服务端）</p><p>S2 使用SocketID进行端口绑定（自动完成）</p><p>客户端在本地的端口绑定一般由内核根据一定的算法来选择一个临时端口作为源端口，因此不必手动调用bind函数(手动指定容易造成端口冲突)</p><p>S3 使用connect向服务端发起连接请求，如果是TCP协议则触发三次握手流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *servaddr, <span class="hljs-type">socklen_t</span> addrlen)</span></span><br></code></pre></td></tr></table></figure><ul><li>servaddr：服务端地址+端口</li><li>addrlen：服务端地址和端口信息长度</li></ul><p>三次握手流程</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/65cef2c44480910871a0b66cac1d5529.png" alt="三次握手"></p><ol><li>客户端发送SYN包，同时发送当前序列号j，客户端进入SYNC_SENT状态（阻塞）</li><li>服务端接收到SYN后，返回ACK（j+1）作为应答，同时发送一个SYN包（k）来检测客户端的响应状态，最后服务端进入SYNC_RCVD状态（阻塞）</li><li>客户端接收到ACK（j+1），即connect调用返回，表示客户端到服务器的单向连接已建立，客户端状态转为ESTABLISHED，最后向服务端发送ACK（k+1），代表客户端响应正常。</li><li>服务端接收ACK（k+1），即accept调用返回，表示服务端到客户端的单向连接也建立成功，服务器状态转为ESTABLISHED。</li></ol><p>————————————————————————————————————————————————————————————</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>确定数据传输路线。选择合适的路由和节点。IP、ICMP（IP包传输错误和性能监测）、ARP、RARP</p><p><strong>同一局域网A ping B流程，会用到哪些网络协议？</strong></p><p>ping 工作在应用层，直接使用网络层的ICMP（Internet Control Message Protocol）协议</p><p>主要用到ICMP协议和ARP协议</p><p>首先使用ARP协议获取到MAC地址，本机查路由表、ARP缓存，直到定位到下一个节点的MAC地址，路由器返回</p><p>ARP主要获取IP地址对应的MAC地址</p><p>ICMP主要由路由器发送？消息类型包括</p><p>目标不可达消息3：路由器无法将数据包转发给目标地址时返回此消息</p><p>重定向消息5：请求主机路由表匹配失败使用默认路由发送时，默认路由器将更优的路径返回给请求主机。</p><p>超时消息11：IP包中的TTL（终于看到这个了）每经过一次路由就-1，变为0时IP包丢弃，此时路由器返回一个ICMP超时消息</p><p>回送消息0、8：消息送达（ping指令）</p><p>原点抑制、路由探索（路由器请求、路由器公告）、地址掩码</p><p>ICMPv6：在IPv6中替代ARP，融合了ARP、ICMP重定向和ICMP路由探索，</p><p><strong>ARP协议工作流程，ARP表记录那些字段？</strong></p><p>IP、MAC地址</p><p><strong>Arp协议中网关怎么去转换ip地址到对应MAC地址的？</strong></p><p>先查ARP缓存，如果有的话直接返回。否则向整个子网广播ARP请求，请求包括目的IP地址，当目的主机接受到ARP请求后将自己的IP地址塞入ARP响应包返回给源主机。源主机和目的主机都会将对方的IP和MAC地址缓存一段时间。每执行一次ARP都会清空对应的缓存。</p><p><strong>如果数据包不在当前子网内，怎么传输到目标子网网关的</strong></p><p>通过DNS获取IP地址，ARP查路由表和ARP缓存获取下一节点MAC地址，再</p><p><strong>局域网内通信流程，跨局域网通信流程</strong></p><p>路由表规则？要到达目标地址走哪一个网关，使用目标地址与路由表中所有条目比较匹配，</p><p>路由表记录指向目的地的路径，</p><p>DNS使用哪些协议？</p><p>MAC（Media Access Control）表：已知MAC地址后进行通讯，位于交换机中，记录局域网内主机端口MAC地址 到 交换机端口的映射。</p><pre><code class=" mermaid">graph LRA(源MAC地址 源端口 目的MAC地址 目的端口)B[MAC表记录 源MAC地址+源端口]C[MAC表查找 目的MAC地址+目的端口]D&#123;找到对应条目?&#125;E[向目的端口单播]F[向除源端口外的所有端口广播]A--&gt;B--&gt;C--&gt;DD--&gt;|是| ED--&gt;|否| F</code></pre><p>ARP（Address Resolution Protocol）表：根据IP获取MAC地址，位于每个拥有IP地址节点（主机、交换机需配置IP、路由器）上，记录主机IP地址 到 MAC地址的映射。</p><p>路由表：</p><p>直连路由：</p><p>非直连路由：</p><p>IP地址划分有一定的从属规则，可以方便网络管理，MAC地址是完全随机的。IP是一个逻辑地址，MAC相当于物理地址，便于替换。</p><p><a href="https://cloud.tencent.com/developer/article/1173761">转发表(MAC表)、ARP表、路由表总结 - 腾讯云开发者社区-腾讯云</a></p><p>默认网关只能有一个，可以手动写入一条静态路由，让走向另一网段的数据默认走第二个网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 网段2 为 10.10.10.1，机器上第二块网卡IP为10.40.4.200, 就是把第二网段所有IP10.xxx.xxx.xxx全都指向10.40.4.200转发<br>route add -p 10.0.0.0 mask 255.0.0.0 10.40.4.200<br></code></pre></td></tr></table></figure><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>————————————————————————————————————————————————————————————</p><p><strong>数据链路层：负责数据帧封装、拆装、传输、差错检测和MAC寻址</strong></p><p>————————————————————————————————————————————————————————————</p><h3 id="（1）数据链路层怎么传输数据的？"><a href="#（1）数据链路层怎么传输数据的？" class="headerlink" title="（1）数据链路层怎么传输数据的？"></a><strong>（1）数据链路层怎么传输数据的？</strong></h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层：负责在物理网络中以比特流透明传输网络帧。</p>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】Go并发编程</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Go/Go%E5%B9%B6%E5%8F%91/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Go/Go%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span>&#123;<br>  state <span class="hljs-type">int32</span> <br>  <span class="hljs-comment">// 29 bits Waiters 阻塞等待的waiter数量 ｜ 1 bit Starving  是否处于饥饿状态 ｜ 1 bit Woken 是否有goroutine被唤醒 | 1 bit Locked 是否被锁定</span><br>  sema <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）如何解决饥饿？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）设置正常模式和饥饿模式</p><ul><li><strong>正常模式：</strong>FIFO等待队列中队首的goroutine会和新到达的goroutine竞争，新到来的goroutine更有优势。</li><li><strong>饥饿模式：</strong>锁释放后直接转交给FIFO队首的goroutine，新到达的goroutine直接加入等待队列队尾。</li><li><strong>正常模式转饥饿模式：</strong>FIFO队首goroutine等待超过1ms。</li><li><strong>饥饿模式转正常模式：</strong>当前加锁goroutine等待小于1ms 或 当前加锁goroutine为等待队列队尾。</li><li>正常模式下新到达的goroutine更有优势是因为将锁转交给正在执行的goroutine可以避免上下文切换开销。</li><li>正常模式下新到达的goroutine未获得锁会进入自旋：（1）未超出自旋次数上限（2）CPU核心大于1（3）GMP中P大于1，且P对应的本地G队列为空</li></ul><p><strong>等待队列的队首goroutine加锁逻辑</strong></p><pre><code class=" mermaid">graph LRA(Unlock)B[队首协程A被激活]C[协程A请求锁]D&#123;是否获取到锁?&#125;E[加锁]F&#123;等待超过1ms?&#125;G[转为饥饿模式]H&#123;是否饥饿模式?&#125;I&#123;等待小于1ms?&#125;J&#123;是否队尾?&#125;K[退出饥饿模式]L(结束)  A --&gt; B  B --&gt; C  C --&gt; D  D --&gt;|是| E  D --&gt;|否| F  F --&gt;|是| G  E --&gt; H  H --&gt;|是| I  H --&gt;|否| L  I --&gt;|是| K  I --&gt;|否| J  J --&gt;|是| K  J --&gt;|否| LK --&gt; L  G --&gt; L</code></pre><p><strong>新到达goroutine加锁逻辑</strong></p><pre><code class=" mermaid">graph LRA(Lock)B&#123;是否饥饿模式?&#125;C[协程A请求锁]D&#123;是否获取到锁?&#125;E[协程A加入等待队列]F&#123;是否满足自旋?&#125;G[自旋次数+1]H[加锁]I(结束)A --&gt; BB --&gt;|是| EB --&gt;|否| CE --&gt; IH --&gt; IC --&gt; DD --&gt;|是| HD --&gt;|否| FF --&gt;|否| EF --&gt;|是| GG --&gt; C</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>避免重入。可重入锁是指拥有锁的进程再请求锁不会阻塞而是直接返回，因此可以实现递归。Mutex不是可重入锁。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基于Mutex的重入锁实现</span><br><span class="hljs-comment">// go get -u github.com/petermattis/goid</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/petermattis/goid&quot;</span><br><br><span class="hljs-keyword">type</span> ReentrantLock <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex <span class="hljs-comment">// 内嵌锁</span><br>owner <span class="hljs-type">int64</span><br>reuse <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *ReentrantLock)</span></span> Lock() &#123;<br>me := goid.Get()<br><br><span class="hljs-comment">// 当前goroutine直接返回</span><br><span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.owner) == me &#123;<br>m.reuse++<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 正常等待加锁</span><br>m.Mutex.Lock()<br>atomic.StoreInt64(&amp;m.owner, me)<br>m.reuse = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *ReentrantLock)</span></span> Unlock() &#123;<br>me := goid.Get()<br><br><span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.owner) != me &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;%v unlock a lock of %v&quot;</span>, me, m.owner))<br>&#125;<br><br>m.reuse--<br><span class="hljs-keyword">if</span> m.reuse != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>atomic.StoreInt64(&amp;m.owner, <span class="hljs-number">-1</span>)<br>m.Mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>避免Lock&#x2F;Unlock不成对 </p></li><li><p>避免死锁 </p></li><li><p>避免Mutex Copy</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>详解：<a href="https://zhuanlan.zhihu.com/p/501972241">深入分析Golang的Mutex - 知乎</a></p><p>关于Woken位：<a href="https://cloud.tencent.com/developer/article/1876245">Go高阶11，手摸手带你深入了解 Mutex 实现原理 - 腾讯云开发者社区-腾讯云</a></p><p>关于等待队列：<a href="https://www.bilibili.com/video/BV1ZQ4y1f7go/?vd_source=e457f02244cca597ca84729193bd5caf">【Golang】信号量 - runtime提供的等待队列_哔哩哔哩_bilibili</a></p><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><h3 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span>&#123;<br>    w Mutex<br>    writerSem <span class="hljs-type">uint32</span><span class="hljs-comment">// 写等待队列</span><br>    readerSem <span class="hljs-type">uint32</span><span class="hljs-comment">// 读等待队列</span><br>  readerCount <span class="hljs-type">int32</span><span class="hljs-comment">// 读锁计数，当writer获取到锁，则readerCount(&gt;=0)反转为readerCount-rwmutexMaxReaders(&lt;0)</span><br>    readerWait <span class="hljs-type">int32</span><span class="hljs-comment">// 加写锁时，若readerCount不为0，则将readerCount赋给readerWait，并将writer加入等待队列，当readerWait减为0时唤醒</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）读写锁优先级？</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）Go中实现了写优先。一个阻塞中的加写锁会排除新的读锁。</p><ul><li><p>读锁在无写等待的情况下可以直接获取；有写等待的情况下需要加入等待队列，不添加新的读锁。</p></li><li><p>写锁在获取前首先要获得内部的<code>mutex</code>，然后需要等待写锁全部释放才能获取。</p></li><li><p>读锁在无写等待的情况下直接释放；有写等待时需要修改<code>Wait</code>并判断是否唤醒<code>writer</code>。</p></li><li><p>写锁释放时首先还原<code>Count</code>，然后唤醒所有等待的<code>reader</code>，最后释放内部<code>mutex</code>。</p></li><li><p><code>readerCount</code>为正时代表当前无<code>writer</code>等待，<code>readerCount</code>记录<code>当前reader数量</code>；</p></li><li><p><code>readerCount</code>为负时代表当前有<code>writer</code>等待，<code>readerCount</code>记录<code>当前reader数量-最大reader数量</code></p></li><li><p><strong><code>readerWait</code>仅在有<code>writer</code>等待时使用。</strong><code>writer</code>进入等待前会将<code>readerCount</code>记录在<code>readerWait</code>中，每当调用<code>RUnlock</code>时会使<code>readerWait-1</code>，当减为0时代表写锁释放完毕，可以唤醒<code>writer</code>。</p></li></ul><pre><code class=" mermaid">graph LR  A(RLock)  B[Count++]  C&#123;Count&lt;0?&#125;  D[加入读等待队列]  E[加读锁成功]  F(结束)  A --&gt; B  B --&gt; C  C --&gt;|是|D  C --&gt;|否|E  E --&gt; F  D --&gt; F    A1(RUnlock)  B1[Count--]  C1&#123;Count&lt;0?&#125;  D1[Wait--]  E1&#123;Wait==0?&#125;  F1[唤醒writer]  G1(结束)  A1 --&gt; B1  B1 --&gt; C1  C1 --&gt;|是|D1  C1 --&gt;|否|G1  D1 --&gt;E1  E1 --&gt;|是|F1  E1 --&gt;|否|G1    A2(Lock)  B2[w.Lock]  C2[Count -= maxCount]  D2&#123;Count != 0?&#125;  E2[Wait = Count]  F2[加入写等待队列]  G2[加写锁成功]  H2(结束)  A2--&gt;B2  B2--&gt;C2  C2--&gt;D2  D2--&gt;|是|E2  E2--&gt;F2  D2--&gt;|否|G2  G2--&gt;H2  F2--&gt;H2    A3(Unlock)  B3[Count += maxCount]  C3[唤醒所有reader]  D3[w.Unlock]  E3(结束)  A3--&gt;B3  B3--&gt;C3  C3--&gt;D3  D3--&gt;E3</code></pre><p>（2）读优先的话可以去掉<code>Wait</code>，只通过<code>Count</code>是否为0来判断写锁是否可以获取。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>避免复制锁</p></li><li><p>避免writer内部重入</p></li><li><p>避免reader内部调用writer重入</p></li><li><p>避免reader内部调用reader重入（如计算阶乘）</p></li><li><p>避免释放未加锁的RWMutex</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// unsafe获取锁内部变量</span><br><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span>&#123;<br>    sync.RWMutex<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RWMutex)</span></span> CountReader() &#123;<br>reader := atomic.LoadInt32((*<span class="hljs-type">int32</span>)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(m)) + unsafe.Sizeof(sync.Mutex&#123;&#125;) + unsafe.Sizeof(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))*<span class="hljs-number">2</span>)))<br><br><span class="hljs-keyword">if</span> reader != <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;ReaderCount is %v\n&quot;</span>, reader)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// m.RLock()</span><br><span class="hljs-comment">// reader = atomic.LoadInt32((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;m)) + unsafe.Sizeof(sync.Mutex&#123;&#125;) + unsafe.Sizeof(uint32(0))*2)))</span><br>fmt.Printf(<span class="hljs-string">&quot;ReaderCount is %v\n&quot;</span>, reader)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><h3 id="底层结构-2"><a href="#底层结构-2" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span>&#123;<br>    noCopy noCopy<br>    state1 [<span class="hljs-number">3</span>]<span class="hljs-type">uint32</span> <span class="hljs-comment">// 64位：waiter数，waitGroup计数，信号量；32位下信号量，waiter数，waitGroup计数。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关问题-2"><a href="#相关问题-2" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）waiter数和计数值区别？</p><ul><li><code>waitGroup</code>计数使用<code>wg.Add()</code>添加，记录当前未完成的任务数，任务完成后调用<code>wg.Done()</code>使计数-1，减为0时修改信号量;</li><li><code>waiter</code>计数使用<code>wg.Wait()</code>添加，记录当前等待的任务数。调用<code>wg.Wait()</code>的goroutine会循环等待。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>需要等所有Add完成后再Wait</p></li><li><p>重用WaitGroup时必须等wg变为0后才可以重新Add</p></li></ul><h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><h3 id="相关问题-3"><a href="#相关问题-3" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）如何监测条件变量？</p><ul><li><code>Signal</code>：唤醒第一个goroutine（notify）</li><li><code>Broadcast</code>：唤醒等待队列中全部goroutine（notifyAll）</li><li><code>Wait</code>：将调用者放入等待队列（<strong>必须持有锁</strong>），阻塞，等待被Signal或Broadcast唤醒后再次检测条件，</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)<br><br>c.L.Lock()<br><span class="hljs-keyword">for</span> !condition &#123;<br>    c.Wait()<br>&#125;<br>c.L.Unlock()<br><br>c.Singal()<br>c.Broadcast()<br></code></pre></td></tr></table></figure><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><h3 id="底层结构-3"><a href="#底层结构-3" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span>&#123;<br>    done <span class="hljs-type">uint32</span><br>    m Mutex<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关问题-4"><a href="#相关问题-4" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）如何保证只实现一次？</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）只执行一次，注意要使用doSlow来避免修改了done状态而需要使用的变量还未初始化完毕的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>done <span class="hljs-type">int32</span><br>v    <span class="hljs-type">int32</span><br>&#125;<br><span class="hljs-comment">// 划分成fast path 和 slow path方便内联</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(one *Once)</span></span> Do() &#123;<br><span class="hljs-keyword">if</span> atomic.LoadInt32(&amp;one.done) == <span class="hljs-number">0</span> &#123;<br>one.doSlow()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(one *Once)</span></span> doSlow() &#123;<br>one.Lock()<br><span class="hljs-keyword">defer</span> one.Unlock()<br><span class="hljs-keyword">if</span> atomic.LoadInt32(&amp;one.done) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 和单例模式里的双检锁一样</span><br><span class="hljs-keyword">defer</span> atomic.StoreInt32(&amp;one.done, <span class="hljs-number">1</span>)<br>one.v = <span class="hljs-number">1000</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><h3 id="底层结构-4"><a href="#底层结构-4" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> &#123;<br>    mu Mutex<br>    read atomic.Value <span class="hljs-comment">// 只读缓存</span><br>    dirty <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]*entry <span class="hljs-comment">// 读写缓存</span><br>    misses <span class="hljs-type">int</span> <span class="hljs-comment">// 每次从dirty中读取就+1，当等于dirty长度时dirty提升为read并清空dirty</span><br>&#125;<br><br><span class="hljs-keyword">type</span> readOnly <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">//read结构</span><br>    m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]*entry<br>    amended <span class="hljs-type">bool</span> <span class="hljs-comment">// 当dirty包含read中不存在的项时为true</span><br>&#125;<br><br><span class="hljs-comment">// 标识删除的项</span><br><span class="hljs-keyword">var</span> expunged = unsafe.Pointer(<span class="hljs-built_in">new</span>(<span class="hljs-keyword">interface</span>&#123;&#125;))<br><br><span class="hljs-comment">// 标识一项</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span>&#123;<br>    p unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关问题-5"><a href="#相关问题-5" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）如何保证哈希并发访问安全同时保证读写效率？</p><p>答：concurrent-map分片加锁，根据哈希值划分多个区间，为每个区间设置单独的锁。sync.Map设置双重缓冲区。</p><p>（2）同一个值只存在于read或dirty的一个中吗？</p><p>答：不是，可能都存在。读的时候尽量多从read中读，写的时候更新read，当read不存在值时加锁写dirty，避免了对read全表加锁。</p><p>（3）dirty升为read会覆盖read原有的key吗？</p><p>答：会。</p><p>（4）misses记录从read中读取miss的次数，假设每次都读一个不存在的值，读取多次就会把dirty升为read，会不会覆盖掉read中未使用的key?</p><p>答：升为read后dirty置为nil，此时不会进入miss相关逻辑，因此不会重复覆盖。在dirty为nil时的第一次Store操作会将read所有非空值内容回写到dirty，然后将新key写dirty，避免了未使用的read键被丢弃。read相当于dirty的快照，支持更新、删除、读取，dirty支持更新、删除、读取、插入。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>Store</strong></p><ul><li><p>更新read中存在的项→直接cas更新</p></li><li><p>更新read中不存在的项或cas更新失败→加锁访问dirty，双检查，若存在值则更新</p></li><li><p>更新read和dirty中都不存在的项→新值添加到dirty</p></li></ul><p><strong>Load</strong></p><ul><li><p>读取read中存在的项→直接返回</p></li><li><p>读取read中不存在的项→从dirty中读取并返回</p></li></ul><p><strong>Delete</strong></p><ul><li>参考Load流程，从读到的位置删除</li></ul><p><strong>LoadOrStore</strong></p><p><strong>LoadAndDelete</strong></p><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://cloud.tencent.com/developer/article/1818000">看过这篇剖析，你还不懂 Go sync.Map 吗？ - 腾讯云开发者社区-腾讯云</a></p><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p>保存一组可独立访问的<strong>临时</strong>对象</p><h3 id="相关问题-6"><a href="#相关问题-6" class="headerlink" title="相关问题"></a>相关问题</h3><p>（1）local切换到victim的时机？</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><strong>New</strong>：需要设置，当调用Get无资源时会使用New新建一个资源并返回，如果未设置New则会返回Nil</li><li><strong>Get</strong>：从Pool中返回一个资源，可能返回nil<ol><li>首先从本地private获取</li><li>再尝试从本地shared获取一个</li><li>尝试从其他P的shared获取一个</li><li>尝试从本地victim执行1-3</li><li>尝试New</li></ol></li><li><strong>Put</strong>：将一个资源返回给Pool<ol><li>首先尝试设置本地private</li><li>本地private不为空则加入到本地shared</li></ol></li><li>victim：即将垃圾回收的资源</li><li>local：当前可用资源</li></ul><h2 id="sync-Context"><a href="#sync-Context" class="headerlink" title="sync.Context"></a>sync.Context</h2><h3 id="底层结构-5"><a href="#底层结构-5" class="headerlink" title="底层结构"></a>底层结构</h3><p>带<strong>过期时间、结束标记和结束原因</strong>的Dict</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span>&#123;<br>  Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">// 返回Context截止日期 ok=false时无截止日期</span><br>  Done() &lt;- <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 在Context被取消时chan会被close</span><br>  Err() <span class="hljs-type">error</span> <span class="hljs-comment">//获取Done的chan被close的原因</span><br>  Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 获取Context中key对应的value</span><br>&#125;<br><br>context.Background()<span class="hljs-comment">// 返回空的、非nil、无截止日期、不会超时、不会cancel的context</span><br></code></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li><p>Context主要作用：取消goroutine运行atomic </p></li><li><p>WithValue方法：向context中添加键值对</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span>&#123;<br>  Context<br>  key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>WithCancel方法：返回parent的副本，把副本加入到parent的child中，当paretn取消时获取通知？跟随问题，一个cancelCtx关闭会导致其所有子ctx关闭，而不会影响父ctx</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  ctx, cancel := context.WithCancel(context.Background()) <span class="hljs-comment">// 创建当前线程的context副本</span><br>  <br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>      fmt.Println(<span class="hljs-string">&quot;goroutine exit&quot;</span>)<br>    &#125;()<br>    <br>    <span class="hljs-keyword">for</span>&#123;<br>      <span class="hljs-keyword">select</span>&#123;<br>        <span class="hljs-keyword">case</span> &lt;- ctx.Done(): <span class="hljs-comment">// 子线程监控ctx是否取消</span><br>        <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">default</span>:<br>        time.Sleep(time.Second)<br>      &#125;<br>    &#125;<br>  &#125;()<br>  <br>  time.Sleep(time.Second)<br>  cancel() <span class="hljs-comment">// 调用副本context的cancel函数取消副本</span><br>  time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>WithTimeout方法：添加超时时间（超时时间+当前时间&#x3D;截止时间）</p></li><li><p>WithDeadline方法：返回parent副本，并添加一个截止时间。当截止时间到了或parent关闭或cancel调用时会关闭</p></li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>Context一般放在函数第一个参数</li><li>默认值应使用background而不是nil</li><li>不能持久化</li><li>key不应该是内建类型，而应该是自己定义的类型</li></ul><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>提供内存屏障</p><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul><li><p>Add</p></li><li><p>CompareAndSwap</p></li><li><p>Swap 返回旧值</p></li><li><p>Load</p></li><li><p>Store</p></li><li><p>atomic.Value，原子地存取任意类型，但只能存取（新版本好像支持swap了？）</p></li></ul><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h3 id="底层结构-6"><a href="#底层结构-6" class="headerlink" title="底层结构"></a>底层结构</h3><p><strong>双指针+循环队列</strong>存数据，还有两个等待队列分别对应读写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 底层结构</span><br>buf unsafe.Pointer <span class="hljs-comment">// 存放元素的循环队列的buffer</span><br>sendx <span class="hljs-type">uint16</span> <span class="hljs-comment">// send在buf中的索引</span><br>recvx <span class="hljs-type">uint16</span> <span class="hljs-comment">// recv在buf中的索引</span><br>recvq waitq <span class="hljs-comment">// 接收等待队列</span><br>sendq waitq <span class="hljs-comment">// 发送等待队列</span><br>lock mutex <span class="hljs-comment">// 互斥锁，保护所有字段</span><br><br>runtime.hchan<br>qcount <span class="hljs-type">uint</span> <span class="hljs-comment">// chan中已有元素数量</span><br>dataqsiz  <span class="hljs-type">uint</span> <span class="hljs-comment">// chan队列大小</span><br>elemsize <span class="hljs-type">uint16</span><span class="hljs-comment">// chan中元素的大小</span><br>closed <span class="hljs-type">uint32</span><span class="hljs-comment">// chan是否关闭</span><br>elemtype *_type <span class="hljs-comment">// chan中元素类型</span><br></code></pre></td></tr></table></figure><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> <span class="hljs-comment">// 发送接收string</span><br><span class="hljs-keyword">chan</span> &lt;- <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 只能发送struct</span><br>&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><span class="hljs-comment">// 只能接收int </span><br>&lt;- 尽量和左边的 <span class="hljs-keyword">chan</span> 结合<br><br><span class="hljs-comment">// 必须初始化才能使用，默认为nil</span><br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, capacity)<br><br><span class="hljs-comment">// 发送数据</span><br>ch &lt;- <span class="hljs-number">2000</span><br><br><span class="hljs-comment">// 接收数据</span><br>&lt;- ch<br><br><span class="hljs-comment">// chan close后可能返回0值，需要使用第二个返回值判断？</span><br>val, err := &lt;- ch <span class="hljs-comment">// err = true 未关闭 err = false 已关闭</span><br><br><span class="hljs-comment">// 关闭chan</span><br><span class="hljs-built_in">close</span>(ch)<br><br><span class="hljs-comment">// 容量</span><br><span class="hljs-built_in">cap</span>(ch)<br><br><span class="hljs-comment">// 长度</span><br><span class="hljs-built_in">len</span>(ch)<br><br><span class="hljs-comment">// select</span><br><span class="hljs-keyword">select</span>&#123;<br>  <span class="hljs-keyword">case</span> val:=&lt;- ch:<br>  <span class="hljs-keyword">case</span> ch&lt;-i:<br>&#125;<br><br><span class="hljs-comment">// range</span><br><span class="hljs-keyword">for</span> v:= <span class="hljs-keyword">range</span> ch&#123;<br>  <br>&#125;<br><br><span class="hljs-comment">// clear</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> ch&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如何保证单向chan？</span><br><br><span class="hljs-comment">// send</span><br><span class="hljs-number">1.</span> <span class="hljs-keyword">chan</span>为<span class="hljs-literal">nil</span>，阻塞<br><span class="hljs-number">2.</span> <span class="hljs-keyword">chan</span>已<span class="hljs-built_in">close</span>，<span class="hljs-built_in">panic</span><br><span class="hljs-number">3.</span> <span class="hljs-keyword">chan</span>已满，且不想被阻塞，直接返回？<br><span class="hljs-number">4.</span> recvq还有等待者，直接将send内容转交给receiver，不进入<span class="hljs-keyword">chan</span> buf<br><span class="hljs-number">5.</span> 否则放入<span class="hljs-keyword">chan</span> buf<br><span class="hljs-number">6.</span> 若buf已满则加入sendq<br><br><span class="hljs-comment">// recv</span><br><span class="hljs-number">1.</span> <span class="hljs-keyword">chan</span>为<span class="hljs-literal">nil</span>，阻塞<br><span class="hljs-number">2.</span> <span class="hljs-keyword">chan</span> <span class="hljs-built_in">close</span>且<span class="hljs-keyword">chan</span>为空，返回&#123;<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>&#125;;<span class="hljs-keyword">chan</span> <span class="hljs-built_in">close</span>且<span class="hljs-keyword">chan</span>不为空，返回&#123;val, <span class="hljs-literal">true</span>&#125;<br><span class="hljs-number">3.</span> 若buf有元素，则取出一个元素返回<br><span class="hljs-number">4.</span> 若buf为空，且sendq有等待者，则从sender中弹出一个将其数据返回给receiver（无缓存channel）<br><span class="hljs-number">5.</span> 若buf为空，且sendq无等待者，则加入recvq阻塞<br><br><span class="hljs-comment">// close</span><br><span class="hljs-number">1.</span> <span class="hljs-keyword">chan</span>为<span class="hljs-literal">nil</span>或已经<span class="hljs-built_in">close</span>则<span class="hljs-built_in">panic</span><br><span class="hljs-number">2.</span> 否则移除waitq和recvq所有成员，移除并唤醒<br></code></pre></td></tr></table></figure><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>关闭和发送前检查chan是否可用？<ul><li>close nil chan</li><li>send close chan</li><li>close close chan</li></ul></li><li>ch返回时必须有一个receiver，否则会阻塞。unbuffered chan buf大小为0，容易阻塞</li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>反射操作，同时监控多个chan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createCases</span><span class="hljs-params">(chs ... <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> []reflect.SelectCase&#123;<br>    cases := <span class="hljs-built_in">make</span>([]reflect.SelectCase)<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> chs&#123;<br>        cases = <span class="hljs-built_in">append</span>(cases, reflect.SelectCase&#123;<br>            Dir: reflect.SelectRecv,<br>            Chan: reflect.ValueOf(ch),<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> chs&#123;<br>        cases = <span class="hljs-built_in">append</span>(cases, reflect.SelectCase&#123;<br>            Dir: reflect.SelectSend,<br>            Chan: reflect.ValueOf(ch),<br>            Send: v,<br>        &#125;)<br>    &#125;    <br>    <span class="hljs-keyword">return</span> cases<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    cases := createCases(ch1, ch)<br>    <br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++&#123;<br>        chosen, recv, ok := reflect.Select(cases)<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>指令重排序：goroutine内部保证变量按声明顺序初始化</p><p>init函数：</p><ol><li>包p导入了包q，则q的init一定happens before p的任何初始化代码</li><li>main函数一定在导入包的init函数之后执行</li><li>包级别的变量在同一文件中按声明顺序初始化，除非其初始化时依赖同一个包下其他文件的变量</li><li>只保证本包下的变量可以按依赖关系初始化，不同包的init函数按文件名顺序初始化</li></ol><p>启动goroutine的go语句执行一定happens before此goroutine内代码执行，因此传入goroutine的参数一定在传入之前就计算完成</p><p>Chan</p><ul><li><p>channel的发送操作happens before从channel中接受对应数据的动作</p></li><li><p>close Chan happends before从close的channel中读出零值，</p></li><li><p>unbuffered chan从外部读取数据调用一定happens before chan向外发送数据的调用</p></li><li><p>Chan的容量是m，则第n个receive一定happens before第n+m个send（不能超出Chan容量）</p></li></ul><p>Mutex</p><ul><li>第n次Unlock一定happens before第n+1次lock的返回</li><li>RWMutex的第n个Lock方法已经返回，则其第n个Unlock方法一定happens before任意一个Rlock的返回，只要这些方法调用happens after第n个Lock的返回</li><li>RWMutex第n个RLock调用已返回，则第k（k&lt;&#x3D;n）个成功的RUnlock的返回一定happens before任意RUnlock的返回，只要这些Lock方法调用happens after第n次RLock（写锁一定在所有读锁释放后才可以获取）</li></ul><p>WaitGroup</p><ul><li>Wait方法等到计数值归零后才返回</li></ul><p>Once</p><ul><li>once.Do(f)中f函数的单次调用一定happens before任何once.Do(f)调用的返回</li></ul><p>atomic</p><ul><li>无明确保证</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode连接VMware虚拟机</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VSCode%E8%BF%9E%E6%8E%A5VMware%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VSCode%E8%BF%9E%E6%8E%A5VMware%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>1.VMware安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openssh-server<br>systemctl enable ssh.service<br></code></pre></td></tr></table></figure><p>2.开放防火墙端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Step1 查看已开启端口</span><br>firewall-cmd --zone=public --list-ports<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Step2 将22加入防火墙public区域</span><br>firewall-cmd --zone=public --add-port=22/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Step3 更新防火墙规则</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>3.设置固定IP地址</p><p><a href="https://www.yisu.com/zixun/620541.html">Vmware虚拟机如何设置固定IP地址 - 开发技术 - 亿速云</a></p><p>4.vmware配置端口转发规则（编辑→虚拟网络编辑器），将主机的9988端口转发到虚拟机的22SSH端口</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220622083342889.png" alt="image-20220622083342889"><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220622083355257.png" alt="image-20220622083355257"></p><p>5.主机windows开放防火墙规则</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220622083512694.png" alt="image-20220622083512694"></p><p>入站规则→新建规则→端口→TCP&amp;特定本地端口9988→允许连接→完成</p><p>6.另一台主机测试连接VMware所在主机的9988端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet hostIP 9988<br></code></pre></td></tr></table></figure><p>7.指定端口连接SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -p 9988 user@hostIP<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【分布式系统】分布式ID</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    
    <content type="html"><![CDATA[<p>分布式ID</p><p>特性</p><ul><li>全局唯一</li><li>趋势递增（不必连续）</li><li>单调递增</li><li>信息安全（使用不连续id防止信息泄露）</li><li>*包含时间戳（了解ID生成时间）</li></ul><p>需求</p><ul><li>高可用：5个9？？</li><li>低延迟：平均延迟和TP999延迟都要低</li><li>高QPS</li></ul><p>方案</p><p>1.UUID</p><p>保证唯一</p><p>缺点：无序从而导致索引分裂、作为主键太长</p><p>2.数据库递增主键</p><p>缺点：高并发情况下不适用</p><p>2.1 数据库分库分步长递增生成</p><p>缺点：失去单调递增特性，只能做到趋势递增</p><p>3.Redis全局变量</p><p>多Redis集群情况下如何保证id递增？</p><p>4.Snowflake雪花算法</p>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 基础知识&amp;常用指令</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Redis/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="知识脑图"><a href="#知识脑图" class="headerlink" title="知识脑图"></a>知识脑图</h2><p><a href="https://bytedancecampus1.feishu.cn/mindnotes/bmncnmue5p48YWlXIYJk3njYWpf">https://bytedancecampus1.feishu.cn/mindnotes/bmncnmue5p48YWlXIYJk3njYWpf</a></p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 查看当前库指定pattern的key<br>KEYS pattern<br>2. 删除当前库所有key<br>flushdb<br>3. 删除所有库所有key(持久化！！！！)<br>flushall<br>4. 查看内存占用<br>info memory<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tylerneylon.com/a/learn-lua/">Learn Lua in 15 Minutes</a></p><p><a href="https://blog.csdn.net/qq_35787138/article/details/113842241">Redis 如何调试Lua 脚本_黄晓宇的博客-CSDN博客_redis 调试lua脚本</a></p><p><a href="https://blog.csdn.net/weixin_42369687/article/details/123720452">Redis核心技术与实战-学习笔记（三十四）Redis支撑秒杀场景的关键技术和实践_孔汤姆的博客-CSDN博客_redis核心技术与实战</a></p><p><a href="https://juejin.cn/post/7024307688196538375">Redis的事务，Go+lua用起来真香 - 掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题型总结】子序列</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/%E3%80%90%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/%E3%80%90%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">940. 不同的子序列 II - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/count-different-palindromic-subsequences/comments/">730. 统计不同回文子序列 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>解题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>解题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A100工作站显卡驱动配置</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/A100%E5%B7%A5%E4%BD%9C%E7%AB%99%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/A100%E5%B7%A5%E4%BD%9C%E7%AB%99%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>1 查看已安装驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg -l | grep nvidia<br>nvidia-smi<br></code></pre></td></tr></table></figure><p>2 完全卸载NVIDIA显卡驱动（同时要保证nouveau已禁用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get --purge remove &quot;*nvidia*&quot;<br>sudo apt-get autoremove<br></code></pre></td></tr></table></figure><p>3 查看推荐版本驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ubuntu-drivers devices<br>sudo ubuntu-drivers autoinstall<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo apt-get install nvidia-dkms-510</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo dkms install nvidia/510.73.05</span><br></code></pre></td></tr></table></figure><p>4 安装相关管理程序 <a href="https://github.com/pytorch/pytorch/issues/35710#issuecomment-901013741">https://github.com/pytorch/pytorch/issues/35710#issuecomment-901013741</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install -y datacenter-gpu-manager<br>sudo apt-get install cuda-drivers-fabricmanager-510<br>sudo service nvidia-fabricmanager start<br><br>如果遇到<br><br>Job for nvidia-fabricmanager.service failed because the control process exited with error code.<br>See &quot;systemctl status nvidia-fabricmanager.service&quot; and &quot;journalctl -xe&quot; for details.<br><br>先重启<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Failed to initialize NVML: Driver/library version mismatch<br>1. 查看问题所在<br>dmesg|grep -i nvrm -A3<br>2. 定位冲突版本位置<br>locate 510.73.08<br>3. 尝试卸载冲突版本或使用冲突版本对应的驱动<br></code></pre></td></tr></table></figure><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220602111919316.png" alt="image-20220602111919316"></p><p>5 固定内核版本或禁止自动更新</p><p>内核已删除后版本仍然不对，删除boot文件夹下链接并重新建立</p><p><a href="https://blog.csdn.net/checknet/article/details/122257816">Ubuntu20.04固定内核版本_technetfly的博客-CSDN博客_ubuntu锁定内核版本</a></p><p><a href="https://blog.csdn.net/qq_42981205/article/details/104677628">Ubuntu删除多余内核的方法_贾真人的博客-CSDN博客_ubuntu删除内核</a></p><p><a href="https://zhuanlan.zhihu.com/p/413655133">Ubuntu 20.04更换Linux内核 - 知乎</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 查看指定版本<br>dpkg -l &quot;*linux-*&quot; | grep &quot;4.10.0-19&quot; | tr -s &#x27; &#x27; | cut -d&#x27; &#x27; -f2<br>2. 手动删除<br>sudo dpkg --purge --force-all package<br></code></pre></td></tr></table></figure><p>6 安装nvidia-docker</p><p><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#installing-on-ubuntu-and-debian">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#installing-on-ubuntu-and-debian</a></p><p><a href="https://blog.csdn.net/biejieyu1016/article/details/120874915">https://blog.csdn.net/biejieyu1016/article/details/120874915</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【微信小程序】图片上传进度显示</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E6%98%BE%E7%A4%BA/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>1 在全局json中引入WeUI</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;useExtendedLib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;weui&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>2 页面wxml，添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-cells&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-cell weui-cell_uploader&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-cell__bd&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__hd&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">aria-role</span>=<span class="hljs-string">&quot;option&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__overview&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__title&quot;</span>&gt;</span>图片上传<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__info&quot;</span>&gt;</span>&#123;&#123;files.length&#125;&#125;/3<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__bd&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__files&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploaderFiles&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">block</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;files&#125;&#125;&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;*this&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__file weui-uploader__file_status&quot;</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;previewImage&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&#123;&#123;item&#125;&#125;&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&#123;&#123;item.path&#125;&#125;&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;aspectFill&quot;</span> /&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">aria-role</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__file-content&quot;</span>&gt;</span>&#123;&#123;item.progress&#125;&#125;%<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">block</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__input-box&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">aria-role</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;上传&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weui-uploader__input&quot;</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;chooseImage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3 页面js，添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">pictureUrl</span>: <span class="hljs-title function_">getApp</span>().<span class="hljs-property">globalData</span>.<span class="hljs-property">server</span> + <span class="hljs-string">&#x27;/file/fileUpload&#x27;</span>,<br>    <span class="hljs-attr">form</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">ownername</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">files</span>: [],<br>    <span class="hljs-attr">waitPicNum</span>: <span class="hljs-number">3</span>,<br>&#125;,<br><span class="hljs-title function_">chooseImage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>;<br>    wx.<span class="hljs-title function_">chooseImage</span>(&#123;<br>        <span class="hljs-attr">sizeType</span>: [<span class="hljs-string">&#x27;original&#x27;</span>, <span class="hljs-string">&#x27;compressed&#x27;</span>], <span class="hljs-comment">// 可以指定是原图还是压缩图，默认二者都有</span><br>        <span class="hljs-attr">sourceType</span>: [<span class="hljs-string">&#x27;album&#x27;</span>, <span class="hljs-string">&#x27;camera&#x27;</span>], <span class="hljs-comment">// 可以指定来源是相册还是相机，默认二者都有</span><br>        <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>            <span class="hljs-comment">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span><br>            <span class="hljs-keyword">let</span> startIndex = that.<span class="hljs-property">data</span>.<span class="hljs-property">files</span>.<span class="hljs-property">length</span>;<br>            <span class="hljs-keyword">const</span> tempFilePaths = res.<span class="hljs-property">tempFilePaths</span>;<br>            <span class="hljs-keyword">let</span> newFiles = [];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; tempFilePaths.<span class="hljs-property">length</span>; i++)&#123;<br>                <span class="hljs-keyword">let</span> tmp = &#123;<span class="hljs-string">&quot;path&quot;</span>: tempFilePaths[i], <span class="hljs-string">&quot;progress&quot;</span>: <span class="hljs-number">0</span>&#125;;<br>                newFiles = newFiles.<span class="hljs-title function_">concat</span>(tmp);<br>            &#125;<br>            <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newFiles);<br><br>            that.<span class="hljs-title function_">setData</span>(&#123;<br>                <span class="hljs-attr">files</span>: that.<span class="hljs-property">data</span>.<span class="hljs-property">files</span>.<span class="hljs-title function_">concat</span>(newFiles)<br>            &#125;);<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tempFilePaths.<span class="hljs-property">length</span>; i++) &#123;<br>                <span class="hljs-keyword">const</span> uploadTask = wx.<span class="hljs-title function_">uploadFile</span>(&#123;<br>                    <span class="hljs-attr">filePath</span>: tempFilePaths[i],<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;file&#x27;</span>,<br>                    <span class="hljs-attr">url</span>: <span class="hljs-title function_">getApp</span>().<span class="hljs-property">globalData</span>.<span class="hljs-property">server</span> + <span class="hljs-string">&#x27;/file/fileUpload&#x27;</span>,<br>                    <span class="hljs-attr">formData</span>: &#123;<br>                        <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-string">&#x27;post&#x27;</span><br>                    &#125;,<br>                    <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>                        <span class="hljs-comment">// do something</span><br>                        <span class="hljs-keyword">const</span> data = res.<span class="hljs-property">data</span><br>                        <span class="hljs-keyword">let</span> imageTempObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imageTempObj);<br>                        that.<span class="hljs-property">data</span>.<span class="hljs-property">waitPicNum</span>--;<br>                    &#125;,<br>                    <span class="hljs-title function_">fail</span>(<span class="hljs-params">res</span>) &#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fail&quot;</span>);<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>                    &#125;<br>                &#125;)<br>                uploadTask.<span class="hljs-title function_">onProgressUpdate</span>(<span class="hljs-function">(<span class="hljs-params">res2</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">let</span> currProgress = <span class="hljs-string">&#x27;files[&#x27;</span> +(startIndex+i) + <span class="hljs-string">&#x27;].progress&#x27;</span><br>                    that.<span class="hljs-title function_">setData</span>(&#123;<br>                        [currProgress] : res2.<span class="hljs-property">progress</span><br>                    &#125;);<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上传进度&#x27;</span>, res2.<span class="hljs-property">progress</span>)<br>                &#125;)<br>            &#125;<br>        &#125;,<br>    &#125;);<br>&#125;,        <br></code></pre></td></tr></table></figure><p>效果预览</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220601170721373.png" alt="image-20220601170721373"></p><p>参考：</p><p><a href="https://blog.csdn.net/AAAXiaoApple/article/details/121533604">uni.chooseImage 选择上传多张图片_嘿，小苹果的博客-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/1693720">微信小程序实战开发一：在小程序中使用useExtendedLib方法引入官方UI - 云+社区 - 腾讯云</a></p><p><a href="https://github.com/wechat-miniprogram/weui-miniprogram">wechat-miniprogram&#x2F;weui-miniprogram: 小程序WeUI组件库</a></p>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>小程序开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>小程序开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础知识&amp;常用指令</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/MySQL/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="知识脑图"><a href="#知识脑图" class="headerlink" title="知识脑图"></a>知识脑图</h2><p><a href="https://bytedancecampus1.feishu.cn/mindnotes/bmncnLs2G2wgok782PohHiSQ8Uc">https://bytedancecampus1.feishu.cn/mindnotes/bmncnLs2G2wgok782PohHiSQ8Uc</a></p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>意义：</p><ul><li>保证原子性。记录事务开始前数据的状态。</li><li>实现MVCC，读提交和可重复读分别在语句开始和事务开始时确定undo log的可见范围。</li></ul><p>实现方式：</p><p>（1）插入操作记录主键值，回滚时删除主键条目</p><p>（2）删除操作记录主键条目，回滚时插入</p><p>（3）更新操作记录主键条目，回滚时写入</p><p>（4）使用trx_id记录当前数据版本对应的事务id，使用roll_pointer将数据各个版本穿起来。</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/%E7%89%88%E6%9C%AC%E9%93%BE.png" alt="版本链"></p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>意义：</p><p>保证持久性和一致性。为除InnoDB之外的其他引擎提供数据备份功能。</p><p>解决问题：</p><p>redo log和undo log都是InnoDB引擎实现的，对于其他引擎就需要使用在Server层实现的binlog来完成数据备份。</p><p>实现方式：</p><p>（1）记录修改数据的SQL语句（STATEMENT模式），缺点是当语句中使用了UUID或NOW等函数产生的不固定的数据会导致复制不一致。</p><p>（2）记录数据修改后的状态（ROW模式），缺点是STATEMENT只需一条语句就可保存的操作在ROW模式下可能需要大量的条目来保存。</p><p>写入方式：</p><p>追加式写入，写满一个文件就新建文件继续写入。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>意义：</p><p>保证持久性和一致性。提供对事务的支持，记录数据物理页在事务提交后的状态。</p><p>解决问题：</p><p>直接持久化数据条目需要检索并写磁盘，写redo log只需要顺序写入即可。<strong>即将随机写转为顺序写，提升了持久化性能。</strong></p><p>实现方式：</p><p>（1）使用内存中的redo log buffer快速记录修改结果。</p><p>（2）redo log buffer写磁盘的时机包括MySQL正常关闭、buffer达到阈值、定期、事务提交。</p><p>写入方式：</p><p>（1）redo log buffer中循环写入，当写指针遇到写缓存头时MySQL会阻塞并写磁盘，写结束后更新写缓存头。</p><table><thead><tr><th></th><th>binlong</th><th>redo log</th></tr></thead><tbody><tr><td>实现层面</td><td>Server层</td><td>引擎层由InnoDB实现</td></tr><tr><td>存储内容</td><td>STATEMENT、ROW</td><td>物理数据</td></tr><tr><td>写入方式</td><td>顺序写入</td><td>循环写入</td></tr><tr><td>功能</td><td>实现备份、主从复制</td><td>实现持久化</td></tr></tbody></table><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>主要是在binlog和redo log中都记录一下数据刷盘状态，<strong>binlog写磁盘成功就算事务提交成功</strong>。</p><pre><code class=" mermaid">graph LRA(查找行)B&#123;行在内存中?&#125;C[读入内存]D[修改值并写内存]E[写内存redo log buffer]F[redo log prepare]G[写磁盘bin log并记录XID]H[redo log commit并记录XID]A--&gt;BB--&gt;|否|CB--&gt;|是|DC--&gt;DD--&gt;|1|EE--&gt;|2|FF--&gt;|3|GG--&gt;|4|H</code></pre><p>解决错误的方法</p><ul><li>当1发生错误，所有修改未持久化，恢复时不会造成任何影响。</li><li>当2、3发生错误。<strong>redo log可能写入磁盘，binlog未写入磁盘</strong>，会造成主库恢复成功而从库恢复失败的情况。此时主库使用redo log恢复时应查找binlog中是否存在XID相同的条目，如果不存在则抛弃修改。</li><li>当4发生错误，<strong>binlog已写入磁盘，redo log未写入磁盘</strong>，redo log写失败会导致事务失效，主库会抛弃所有修改，而从库只使用binlog进行状态同步，所以从库可能保留主库不存在的修改，从而造成主从不一致的情况。因此主库会比对binlog中的XID和所有prepare状态的事务XID，如果一致则提交XID对应的事务。</li><li>当4发生错误，<strong>binlog和redo log都写入磁盘</strong>，此时只是事务未提交，只需要在恢复的过程中提交事务即可，不必丢弃修改。</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><blockquote><p>库、表查看</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看库<br>show database; <br># 查看表<br>show tables [from database]; <br># 查看当前库<br>select database(); <br># 查看当前版本号<br>select version(); <br># 查看列<br>show columns from table;<br>describe table;<br></code></pre></td></tr></table></figure><blockquote><p>语法规范</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 单行注释<br># 注释<br>-- 注释<br>2. 多行注释<br>/* 注释 */<br></code></pre></td></tr></table></figure><blockquote><p>检索</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 检索不同行 DISTINCT应用于所有列，而不是首列<br>SELECT DISTINCT col1, col2 FROM table;<br>1.1 DISTINCT 也可用于聚合函数<br>COUNT(DISTINCT col)<br>2. 限制检索结果数量<br>SELECT * FROM table LIMIT 5;<br>SELECT * FROM table LIMIT 5, 5; # 起始行, 限制行数<br></code></pre></td></tr></table></figure><blockquote><p>排序</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 排序方向，默认递增（使用索引排序时，方向不同会导致索引失效）<br>ORDER BY xxx DESC; # 递减<br></code></pre></td></tr></table></figure><blockquote><p>检查</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 空值检查<br>IS NULL<br>IS NOT NULL<br></code></pre></td></tr></table></figure><blockquote><p>通配符</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. % 匹配任意字符任意数量<br>col LIKE &#x27;%x&#x27;;<br>2. _ 匹配任意字符一次<br></code></pre></td></tr></table></figure><blockquote><p>正则</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 匹配数量标识（放在匹配条件后）<br>* 0或多个<br>? 0或1个<br>+ 1或多个<br>&#123;n&#125; n个<br>&#123;n, &#125; 至少n个<br>&#123;n, m&#125; n-m个<br><br>2. 匹配位置标识（放在匹配条件前）<br>^ 开头<br>&amp;结尾<br>[[:&lt;:]]单词开头<br>[[:&gt;:]]单词结尾<br><br>3. 匹配逻辑标识<br>[]匹配集合, [015]标识匹配0或1或5<br>|匹配或<br>^否定匹配集合, ^[015]匹配非0非1非5<br>-匹配范围, [0-5]标识匹配0到5<br>[:alpha:]<br>[:alnum:]<br>[:digit:]<br>[:lower:]<br>[:upper:]<br>[:blank:]空格和制表<br>[:space:]所有空白符<br>[:xdigit:][a-fA-F0-9]<br><br>4. 匹配规则<br>.匹配任意单个字符<br>\\ 特殊字符转义<br>正则表达式匹配只要对应列中存在字符即可，不需要全值匹配（除非使用位置标识符）<br></code></pre></td></tr></table></figure><blockquote><p>计算字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">字符串所有计数位置从1开始<br>1. 字符串拼接<br>Concat(string...)<br>2. 字符串去除空格<br>Trim(string) # 两侧<br>LTrim(string)<br>RTrim(string)<br>3. 字符串取值<br>Left(string, len)<br>Right(string, len)<br>Substring(string, pos, len) # pos取负则从末尾开始数<br>4. 字符串转换<br>Upper(stirng)<br>Lower(string)<br>5. 字符串长度<br>Length(string)<br>6. 字符串查找<br>Locate(substr, string)<br><br>1. 数值+-*/<br></code></pre></td></tr></table></figure><blockquote><p>存储过程</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 三目运算符<br>IF(expr, ret1, ret2) <br>2. 判断空值, ret1为NULL则返回ret2<br>IFNULL(ret1, ret)<br>3. IFELSE表达式, 条件满足则执行EXP1，否则执行EXP2<br>IF STATEMENT THEN<br>EXP1<br>ELSE<br>EXP2<br>END IF;<br>4. 多个数最大最小值<br>GREATEST(exp1, exp2, exp3)<br>LEAST(exp1, exp2, exp3)<br>5. SWITCH CASE<br>CASE status<br>    WHEN val1 THEN expr1<br>    WHEN val2 THEN expr2<br>    ELSE defaultexpr<br>END<br>5. 非NULL判断，依次判断，当值不为NULL时返回<br>COALESCE(exp1, exp2, exp3, ... )<br></code></pre></td></tr></table></figure><blockquote><p>逻辑判断</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 范围查询<br>WHERE val BETWEEN VAL1 AND VAL2<br></code></pre></td></tr></table></figure><blockquote><p>数值格式化</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 浮点数四舍五入<br>ROUND(val, valid_bit, default_bit)<br>ROUND(num, 2); # num四舍五入2位，默认0补足<br></code></pre></td></tr></table></figure><blockquote><p>隔离级别</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 查看当前隔离级别<br>select @@transaction_isolation;<br>2. 修改隔离级别<br>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE&#125;<br></code></pre></td></tr></table></figure><blockquote><p>日期操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DATE_SUB(FROMDATE, INTERVAL val &#123;MINUTE|day|hour|second|week|month|quarter|year&#125;)<br>DATE_ADD<br></code></pre></td></tr></table></figure><blockquote><p>DISTINCT</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora配置腾讯云图床</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Typora%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Typora%E9%85%8D%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Typora开启图像自动上传"><a href="#1-Typora开启图像自动上传" class="headerlink" title="1 Typora开启图像自动上传"></a>1 Typora开启图像自动上传</h3><p>上传服务选择<strong>PicGo-Core（command line）</strong>，然后选择下载或更新</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220304110711581.png" alt="image-20220304110711581"></p><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2 修改配置文件"></a>2 修改配置文件</h3><p>选择<strong>打开配置文件</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 建议新建图床专用用户：访问控制-&gt;用户-&gt;用户列表-&gt;新建用户-&gt;快速创建</span><br><span class="hljs-comment">// 访问方式选择 编程访问</span><br><span class="hljs-comment">// 权限选择 QcloudCOSDataWriteOnly和QcloudCOSDataReadOnly</span><br><span class="hljs-comment">// SecretId获取：访问控制-&gt;用户-&gt;用户列表-&gt;用户详情-&gt;API密钥</span><br><span class="hljs-comment">// SecretKey获取：访问控制-&gt;用户-&gt;用户列表-&gt;用户详情-&gt;API密钥</span><br><span class="hljs-comment">// Bucket获取：对象存储-&gt;存储桶列表(存储桶名称就是Bucket)</span><br><span class="hljs-comment">// Area：对象存储-&gt;存储桶列表-&gt;概览-&gt;基本信息-&gt;所属地域中的英文</span><br><span class="hljs-comment">// customUrl：对象存储-&gt;存储桶列表-&gt;概览-&gt;域名信息-&gt;访问域名</span><br><span class="hljs-comment">// appId：未使用</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;current&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tcyun&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tcyun&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;secretId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;secretKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;bucket&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <br>      <span class="hljs-attr">&quot;appId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;area&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;typora/&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;customUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 基础知识&amp;常用指令</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Docker/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Docker/</url>
    
    <content type="html"><![CDATA[<p>本地构建docker image（.代表在Dockerfile所在文件夹）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t imagename:tag .<br></code></pre></td></tr></table></figure><p>本地删除 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi image<br></code></pre></td></tr></table></figure><p>本地删除<none>:<none>image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi $(docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span> -q)<br></code></pre></td></tr></table></figure><p>查看images</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br>docker images --all<br></code></pre></td></tr></table></figure><p>查看container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看正在运行的</span><br>docker ps<br><span class="hljs-comment"># 查看包括未运行的</span><br>docker ps --all<br></code></pre></td></tr></table></figure><p>执行指定容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name=<span class="hljs-string">&quot;rain&quot;</span> -p hostPort:containerPort rain:latest<br></code></pre></td></tr></table></figure><p>查看容器运行输出log</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs containerID<br></code></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> containerID<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 基础知识&amp;常用指令</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Linux/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><a href="https://blog.csdn.net/nazeniwaresakini/article/details/104220111">彻底搞懂文件描述符&#x2F;文件句柄&#x2F;文件指针的区别与联系_LittleMagics的博客-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/d60a2b44e78e">问：说说inode到底是什么？ - 简书</a></p><table><thead><tr><th></th><th>文件描述符 file descriptor</th><th>文件句柄</th><th>文件指针</th></tr></thead><tbody><tr><td>级别</td><td>进程（位于PCB的文件描述表中）</td><td>系统</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>硬链接就像shared_ptr</p><p>软链接就像**</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看linux资源占用情况</span><br>top [-U username]<br>1. 切换显示单位<br><span class="hljs-built_in">shift</span>+E<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># linux终端退出时不中止指令</span><br><span class="hljs-built_in">nohup</span> python test.py &gt; output.log 2&gt;&amp;1 &amp;<br><span class="hljs-comment"># 2&gt;&amp;1 代表将标准错误重定向到标准输出&amp;2，然后再重定向到log中</span><br><span class="hljs-comment"># &amp; 代表在后台执行</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看日志尾部100条</span><br><span class="hljs-built_in">tail</span> -n 100 output.log<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看kern日志（mount 失败的时候可能有用）</span><br><span class="hljs-built_in">tail</span> -f /var/log/kern.log<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前目录文件夹硬盘占用情况</span><br><span class="hljs-comment"># sort -nr为排序</span><br><span class="hljs-comment"># -d 最大深度</span><br><span class="hljs-comment"># -x 跳过mount的目录</span><br><span class="hljs-built_in">du</span> -h -d 1 -x<br></code></pre></td></tr></table></figure><h2 id="解压-x2F-压缩"><a href="#解压-x2F-压缩" class="headerlink" title="解压&#x2F;压缩"></a>解压&#x2F;压缩</h2><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>解压至指定目录（不加-d则默认解压到当前目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -d /dst test.zip<br></code></pre></td></tr></table></figure><p>压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定目录</span><br>zip -r test.zip /src<br><span class="hljs-comment"># 当前目录</span><br>zip -r test.zip *<br></code></pre></td></tr></table></figure><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp local_file remote_username@remote_ip:remote_folder<br>scp -r local_folder remote_username@remote_ip:remote_folder<br></code></pre></td></tr></table></figure><h2 id="目录入栈出栈"><a href="#目录入栈出栈" class="headerlink" title="目录入栈出栈"></a>目录入栈出栈</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 保存当前位置，进入新位置<br>pushd /target_path<br>2. 退回到上一位置<br>popd<br></code></pre></td></tr></table></figure><h2 id="统计命令执行时常"><a href="#统计命令执行时常" class="headerlink" title="统计命令执行时常"></a>统计命令执行时常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">time [command]<br></code></pre></td></tr></table></figure><h2 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -hl：查看磁盘剩余空间<br>df -h：查看每个根路径的分区大小<br>du -sh [目录名]：返回该目录的大小<br>du -sm [文件夹]：返回该文件夹总M数<br>du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹）<br></code></pre></td></tr></table></figure><h2 id="查看所有内核"><a href="#查看所有内核" class="headerlink" title="查看所有内核"></a>查看所有内核</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg --get-selections | grep linux<br>2. 删除内核<br>sudo apt-get purge xxx <br>3. 删除deinstall<br>dpkg --get-selections | grep deinstall | sed &#x27;s/deinstall/\lpurge/&#x27; | sudo dpkg --set-selections<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除标注为“purge”的软件</span><br>sudo dpkg -Pa<br>4. 修改默认内核？？<br>vim /etc/default/grub<br>GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.15.0&quot;<br>sudo update-grub<br></code></pre></td></tr></table></figure><h2 id="全盘查找文件"><a href="#全盘查找文件" class="headerlink" title="全盘查找文件"></a>全盘查找文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">locate file_name<br></code></pre></td></tr></table></figure><h2 id="Vim操作"><a href="#Vim操作" class="headerlink" title="Vim操作"></a>Vim操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 删除行<br>dd<br>2. 删除光标到结尾<br>dG<br>3. 删除全部<br>:$d<br>4. 跳到最后一行<br>shift+g<br></code></pre></td></tr></table></figure><h2 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -a<br>lsb_release -a<br></code></pre></td></tr></table></figure><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd username<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go】Go基础</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Go/Go%E5%9F%BA%E7%A1%80/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/Go/Go%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="知识脑图"><a href="#知识脑图" class="headerlink" title="知识脑图"></a>知识脑图</h2><p><a href="https://bytedancecampus1.feishu.cn/mindnotes/bmncnE7PvN2nMfmvhrQZrVtN9Wf">https://bytedancecampus1.feishu.cn/mindnotes/bmncnE7PvN2nMfmvhrQZrVtN9Wf</a></p><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/14.png" alt="img"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>Golang垃圾回收学习笔记</p><p>先抛出两个问题</p><p>（1）哪些垃圾会被回收，哪些不会</p><p>（2）垃圾回收发生在什么时机</p><p>垃圾回收主要分为垃圾标记和垃圾回收</p><p>垃圾标记算法</p><p>（1）追踪法：暂停程序（Stop the world），从ROOT SET出发，bfs遍历所有可达对象并标记，清除未标记对象。</p><p>（2）引用计数法（例如C++智能指针）：为每个对象设置引用计数量，计数量减为0时及时删除。缺点是引用计数量维护需要开销，同时对于循环引用的情况会导致永远无法回收。</p><p>（3）分代算法（Java里实现）：在上面算法的基础上采用分代机制，对于不同世代的对象采用不同处理机制。</p><p>Go的垃圾标记算法</p><p>Go的垃圾标记主要基于追踪法实现。为了避免STW，引入了三色标记法，使得垃圾回收可以在不暂停其他goroutine的情况下执行。</p><p>Go的垃圾标记操作</p><p>（1）标记准备，打开写屏障</p><p>（2）ROOT SET 中的节点入队列（白色变为灰色）</p><p>（3）遍历队列中节点，已访问节点添加入活跃名单（灰色变为黑色），同时将已访问节点的子节点加入队列（白色变为灰色）</p><p>（4）重复（3），直至队列变为空</p><p>（5）启动STW，扫描栈中所有对象，检查其标记状态，已标记</p><p>标记过程中可能出现的特殊情况</p><p>（1）</p><p>写屏障检测对象变化</p><p>，写屏障是怎么回事？GC开始时打开写屏障，打开写屏障之后所有新创建的对象都会被标记为灰色</p><p>三色不变性</p><p>简单来说就是存在在GC过程中将黑色节点指向某个灰色节点指向的白色节点，同时将灰色节点的引用移除，会导致白色节点无法被标记从而回收</p><p>我们不妨考虑赋值器的写操作，假设某个灰色对象 A 指向白色对象 B， 而此时赋值器并发的将黑色对象 C 指向（ref3）了白色对象 B， 并将灰色对象 A 对白色对象 B 的引用移除（ref2），则在继续扫描的过程中， 白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象）。 进而产生被错误回收的对象 B，如图 1 所示。</p><p>黑色对象不会指向白色对象</p><p>黑色对象指向的白色对象必须包含一个灰色对象的到达路径</p><p>保证三色不变性：</p><p>（1）GC中新建的对象标记为黑色</p><p>（2）</p><p>一轮GC中不会被回收的内存：</p><p>（1）活跃对象的内存（2）本轮GC中新分配的内存（3）</p><p>辅助GC</p><p>在GC中如果goroutine需要分配内存，则其会参与一部分GC工作</p><p>垃圾回收时机：</p><p>触发GC：每次内存分配时检测是否到达阈值，阈值一般为 上次GC内存分配量 * 内存增长率（默认100），即内存翻倍时GC</p><p>定时GC：最长2分钟出发自动GC</p><p>手动GC：runtime.GC</p><p>主要问题：</p><p>（1）STW</p><p>（2）各种异常情况</p><p>垃圾回收简单了解一下java的做法</p><p>写屏障</p><p>结束时一次STW，扫描栈上对象</p><p>删除屏障</p><p>开始时一次STW，保存快照</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>面向对象：</p><ul><li><p>嵌入字段：</p><p>多个嵌入字段有重名变量直接使用会报错，需要制定变量的字段名</p><p>嵌入字段变量和父结构体变量重名会使用父结构体变量覆盖</p></li><li><p>接口</p></li></ul><p><a href="https://www.cnblogs.com/apocelipes/p/14090671.html">golang拾遗：嵌入类型 - apocelipes - 博客园</a></p><h5 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span> 创建goroutine<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>  <br>&#125;()<br><span class="hljs-number">2.</span> 等待goroutine<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">5</span>)<br>wg.Wait()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>  wg.Done()<br>&#125;()<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GO111MODULE=on<br>export GOPROXY=https://goproxy.cn,direct<br><br>go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go mod init envelope-rain # 替换成包名，生成go.mod<br>go mod tidy# 自动下载需要的mod，删除不使用的mod，生成go.sum，更新go.mod<br></code></pre></td></tr></table></figure><h4 id="反射获取类型"><a href="#反射获取类型" class="headerlink" title="反射获取类型"></a>反射获取类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">reflect.TypeOf()<br></code></pre></td></tr></table></figure><h4 id="Interface格式转换"><a href="#Interface格式转换" class="headerlink" title="Interface格式转换"></a>Interface格式转换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-number">1.</span> 获取格式<br>a.(<span class="hljs-keyword">type</span>)<br><span class="hljs-number">2.</span> 格式转换<br>a.(<span class="hljs-type">int32</span>)<br>a.(<span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>  a, ok := a.(<span class="hljs-type">string</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">time.Now().Unix()<br>time.Now().UnixNano()<br></code></pre></td></tr></table></figure><h4 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span> <span class="hljs-type">string</span>转任意进制<span class="hljs-type">int</span><br>strconv.ParseInt(s <span class="hljs-type">string</span>, base <span class="hljs-type">int</span>, bitsize <span class="hljs-type">int</span>) <span class="hljs-comment">// base - 进制 bitsize - int位数</span><br><span class="hljs-number">2.</span> <span class="hljs-type">int</span>转<span class="hljs-type">string</span><br>strconv.FormatInt(<span class="hljs-type">int64</span>(i), base <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h4 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang">str := <span class="hljs-string">&quot;fuck you!&quot;</span><br>str2 := str[<span class="hljs-number">2</span>:]<br>str3 := str[:<span class="hljs-number">5</span>]<br><span class="hljs-comment">// 字节长度</span><br>str4 := <span class="hljs-built_in">len</span>(str)<br><span class="hljs-comment">// 字符长度</span><br>str5 := utf8.RuneCountInString(str)<br><span class="hljs-comment">// Rune码转string</span><br>str6 := <span class="hljs-type">string</span>(str[<span class="hljs-number">3</span>])<br><span class="hljs-number">4.</span> 判断是否为空<br>s == <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">math.Abs(x <span class="hljs-type">float64</span>)<br></code></pre></td></tr></table></figure><h4 id="defer栈"><a href="#defer栈" class="headerlink" title="defer栈"></a>defer栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// defer参数在声明时计算，在函数返回时执行语句，会根据调用顺序，后defer先执行</span><br><span class="hljs-keyword">defer</span> fmt.Println()<br></code></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&amp;&amp; || !<br></code></pre></td></tr></table></figure><h4 id="时间包-time"><a href="#时间包-time" class="headerlink" title="时间包 time"></a>时间包 time</h4><h4 id="枚举类型实现-https-www-jianshu-com-p-ce95d7443c97"><a href="#枚举类型实现-https-www-jianshu-com-p-ce95d7443c97" class="headerlink" title="枚举类型实现 https://www.jianshu.com/p/ce95d7443c97"></a>枚举类型实现 <a href="https://www.jianshu.com/p/ce95d7443c97">https://www.jianshu.com/p/ce95d7443c97</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Enum <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>S1 Enum = <span class="hljs-number">0</span><br>  S2 Enum = <span class="hljs-number">1</span><br>  S3 Enum = <span class="hljs-number">2</span><br>)<br><br>state := S1<br></code></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// case 穿透，防止自动break</span><br><span class="hljs-keyword">fallthrough</span><br></code></pre></td></tr></table></figure><p>乐观锁vs悲观锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 乐观锁</span><br>atomic.AddInt32()<br>atomic.LoadInt32()<br>atomic.StoreInt32()<br><br><span class="hljs-comment">// 悲观锁</span><br>mu.Lock()<br>val++<br>mu.Unlock()<br></code></pre></td></tr></table></figure><h3 id="数据结构和指针"><a href="#数据结构和指针" class="headerlink" title="数据结构和指针"></a>数据结构和指针</h3><h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><p><strong>创建</strong></p><p>例：创建类型为int，长度为5的Slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>例2：类型int，长度0，容量5</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><strong>插入</strong></p><p>使用append函数，s为T类型的Slice，vs为一系列T类型的值</p><p>注意：append会覆盖原始array在切片范围之后的元素，若原始array无法容纳所有元素，则会返回新分配的array</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(s []T, vs ... T)</span></span> []T<br>s := []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p><strong>遍历</strong></p><p>使用range关键字，返回（index，value）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">pow := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">100</span>, <span class="hljs-number">10</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> pow&#123;<br>    <span class="hljs-comment">// some process</span><br>&#125;<br><span class="hljs-comment">// 只取索引</span><br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> pow&#123;<br>    <br>&#125;<br><span class="hljs-comment">// 只取值</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> pow&#123;<br>    <br>&#125;<br><span class="hljs-comment">// 只取索引</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pow&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mp <span class="hljs-keyword">map</span>[key_type]value_type<br><span class="hljs-keyword">var</span> mp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>插入&#x2F;更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mp[key]=elem<br></code></pre></td></tr></table></figure><p>取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mp[key]<br></code></pre></td></tr></table></figure><p>删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(mp, key)<br></code></pre></td></tr></table></figure><p>查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 若elem存在mp中，则ok为true</span><br>elem, ok = mp[key]<br></code></pre></td></tr></table></figure><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>Lat, Long <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Vertex&#123;<br><span class="hljs-string">&quot;Bell Labs&quot;</span>: Vertex&#123;<br><span class="hljs-number">40.68433</span>, <span class="hljs-number">-74.39967</span>,<br>&#125;,<br><span class="hljs-string">&quot;Google&quot;</span>: Vertex&#123;<br><span class="hljs-number">37.42202</span>, <span class="hljs-number">-122.08408</span>,<br>&#125;,<br>&#125;<br><span class="hljs-comment">// 若上层类型只是类型名，则可以省略</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Vertex&#123;<br><span class="hljs-string">&quot;Bell Labs&quot;</span>: &#123;<span class="hljs-number">40.68433</span>, <span class="hljs-number">-74.39967</span>&#125;,<br><span class="hljs-string">&quot;Google&quot;</span>:    &#123;<span class="hljs-number">37.42202</span>, <span class="hljs-number">-122.08408</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span> ret <span class="hljs-type">string</span> &#123;&#125;<br><br>name = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span> ret <span class="hljs-type">string</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>闭包（相当于面向对象class中的static）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addr</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    sum := <span class="hljs-number">0</span> <span class="hljs-comment">// 相当于static</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        sum += x <span class="hljs-comment">// 闭包内函数可以访问到闭包外的变量</span><br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>Go没有class，可以使用type来定义结构体和其对应的方法。只可以使用当前package定义的类型作为receiver，不可以使用其他包中定义的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span>&#123;<br>    x, y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">// func和name之间为结构体方法的receiver（name和type）（name的作用相当于this，在method内部取对象数据）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X+v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>receiver可以是值，也可以是指针。只有指针receiver可以实现在method中修改指向值，因此指针receiver更常见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span>&#123;&#125; <span class="hljs-comment">// 值receiver</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span>&#123;&#125; <span class="hljs-comment">// 指针receiver</span><br></code></pre></td></tr></table></figure><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>定义为一系列method签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span>&#123;<br>    Abs() <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个type通过实现interface的method来实现interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;<br>    S <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span>&#123;<br>    M()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M()&#123;<br>    fmt.Println(t.S)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【分布式系统】GFS论文笔记</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/GFS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/GFS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>GFS 阅读</p><p>设计层面考虑了三点</p><ol><li><p>节点失效很常见，因此必须考虑常量监控、故障检测、错误容忍和自动恢复</p></li><li><p>存储文件很大，因此IO操作和块大小必须仔细考虑</p></li><li><p>大部分文件修改都是在文件末尾新增内容而不是修改内部部分内容，通常是需要顺序遍历文件。</p></li><li><p>通过放宽系统的一致性模型、提供原子性的append操作来提高系统性能。</p></li><li><p>随机访问支持，但不做优化。</p><p>如何实现原子性的append操作？</p></li></ol><p>接口要点：</p><ol><li>原子性的append操作，因为事务多是生产者-消费者队列或是多路归并</li><li>snapshot快照，以较低消耗保存文件或目录结构树的拷贝</li></ol>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【分布式系统】MapReduce论文笔记</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>MapReduce核心：通过Map和Reduce函数实现任务分发和并行计算，通过重执行实现错误容忍</p><p>中间结果需要经过Master分配到各个reducer</p><p>Master的数据结构：</p><p>1⃣️map&#x2F;reduce任务的状态（idle，in-progress、completed）</p><p>2⃣️worker的id，分成idle、in-progress和failed三个列表？</p><p>3⃣️intermediate：由map任务执行得到的R个中间文件的地址和大小，对中间文件地址或大小的修改会通知到所有执行中的reduce worker（对应下面的错误容忍机制）</p><p>错误容忍机制：</p><h3 id="worker失效"><a href="#worker失效" class="headerlink" title="worker失效"></a>worker失效</h3><p>master定期ping worker，如果超时则标记为failed，分配给该worker的所有map&#x2F;reduce 任务都设为初始的idle状态，因此可以分配给其他worker。</p><p>失效的map worker所执行的任务会被重新执行，因为其存储在worker本地不可访问。失效的reduce worker所执行的任务不必执行，因为其存储在gfs。</p><p>这里特例就是失效的是reduce worker且其任务已提交。对于未提交的map&#x2F;reduce和已提交的map都需要重新执行。</p><p>例如执行map task的worker A突然失效，其工作由worker B重新执行，所有原来从A读取数据的reduce worker都会被通知从worker B重新读取数据</p><h3 id="master失效"><a href="#master失效" class="headerlink" title="master失效"></a>master失效</h3><p>通常可以将master的数据保存为checkpoint，这样当master失效时可以备用master启动。</p><h3 id="失效语义"><a href="#失效语义" class="headerlink" title="失效语义"></a>失效语义</h3><p>依赖map&#x2F;reduce的原子操作。</p><p>对于确定性任务，map&#x2F;reduce都会在本地临时文件记录。map执行完成后得到R份reduce文件，向master报告文件位置，如果master已经接收过相同的记录则会自动忽略。reduce对执行后的结果会将其重命名为最终的输出文件，当多个reduce节点执行相同任务时，依赖文件系统命名的原子性来保证只有一个执行结果被命名为最终文件。</p><p>对于不确定性任务，可能对同一个reduce任务有两个不同的结果，这是因为有两个reduce节点读取到了两个不同map节点生成的不同中间文件M？？？？？？</p><h3 id="位置优化"><a href="#位置优化" class="headerlink" title="位置优化"></a>位置优化</h3><p>每一个map任务有多个副本，分别存储在不同机器上。当master分配任务时尽量将任务分配给存储map任务的机器上，否则就分配给存储map任务机器相邻或相同位置（例如同一交换机）的机器上</p><h3 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h3><h3 id="后备任务"><a href="#后备任务" class="headerlink" title="后备任务"></a>后备任务</h3><p>大部分MapReduce任务都受任务即将结束时的部分Stragglers的影响，这些节点受自身网络、硬盘、CPU和内存等问题，导致任务比预期执行时间要长。为此我们设置了后备任务，当MapReduce任务快完成时，master会调度对正在执行中的任务的备份执行，当主节点或备份节点任一完成任务时，该任务就可以被标记为完成。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="划分函数"><a href="#划分函数" class="headerlink" title="划分函数"></a>划分函数</h3><p>通常使用 hash(key)&#x2F;R进行划分，但对于有特殊要求的，可以通过用户自定义函数来对key先进行处理，然后再用hash函数</p><h3 id="key递增存储"><a href="#key递增存储" class="headerlink" title="key递增存储"></a>key递增存储</h3><p>保证在partition的分区内key&#x2F;value对按key递增的方式存储</p><h3 id="组合器函数"><a href="#组合器函数" class="headerlink" title="组合器函数"></a>组合器函数</h3><p>在map执行完成之后现在map节点执行一遍reduce的代码？来将结果局部合并 </p><h3 id="输入输出类型"><a href="#输入输出类型" class="headerlink" title="输入输出类型"></a>输入输出类型</h3><p>通过自定义reader来保证输入按照理想的方式进行划分，比如说同一个句子划分在同一个value中</p><h3 id="跳过损坏记录"><a href="#跳过损坏记录" class="headerlink" title="跳过损坏记录"></a>跳过损坏记录</h3><p>在执行map&#x2F;reduce前将参数序列号存储，当代码处理某条记录时发生端错误、总线错误，节点向master发送last gasp的UDP包，当master多次接受到相同记录的错误包时，就会指导map&#x2F;reduce跳过该条记录？？？如何实现 hashmap记录条目和次数，超过阈值就返回指令说让节点跳过？？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go build -race -buildmode=plugin ..<span class="hljs-regexp">/mrapps/</span>wc.go<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【分布式系统】Raft论文笔记</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Raft%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Raft%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Raft笔记</p><p>首先要理解的概念：</p><p>term代表leader有效的任期</p><p>Raft主要做的是将主节点选举、日志备份和安全分离开来，加强了一致性的强度来减少需要考虑的状态。</p><p>Raft新特点：</p><ol><li>Strong leader：log条目只从leader流向其他服务器</li><li>Leader election：使用随机timer来选举leader</li><li>Membership changes：联合共识方法，</li></ol><p>复制状态机</p><p>一系列服务器上在相同的状态机副本上进行计算，即使某些server失效了也可以继续操作。因此可以解决一系列容错问题，比如对GFS、HDFS、RAMCloud等只有一个集群leader的大规模系统，通常使用一套单独分离的复制状态机来管理leader选举，并且需要存储一系列配置信息，这些信息必须免疫leader崩溃。也就是说这些系统的集群任务及相关任务分配、节点状态全都只保存在主节点中，主节点必须保证这些信息的非易失。复制状态机包括Chubby、ZooKeeper等。</p><p>复制状态机通常使用replicated log实现（类似MySQL里的redo log？undo log？）例如图1所示，每个server都存储一个包含一系列指令的log，即状态机按顺序执行的内容。每个log文件都以同样的顺序存储相同的指令。（就是把原来在GFS等系统中存储在主节点的管理信息，Raft里在每个子机器上都保存了一份对应的执行log？）</p><p>特点：</p><ol><li>保证在所有非拜占庭情况（系统错误）下永远不返回不正确的结果</li><li>只要server中的大部分保持正常功能并且可以和client通信，那么整个系统就保持完整的功能性。</li><li>不依赖时间timing来保证log的一致性，因为错误的始终和极限的消息延迟可以导致可用性问题。</li><li>通常情况下，只要集群中的大部分对rpc完成了一轮相应，一条命令就可以完成，整个系统的性能不受一小部分较慢的服务器的影响。</li></ol><p><strong>首先选举出一个有别于其他节点的leader，然后将管理复制log的责任完全交给这个leader。</strong>leader接受从client传来的log条目，将log条目复制给所有其他server，然后等待安全之后（？所有其他的server均接受到log条目且log条目没有撤回？）通知所有server将log应用到其状态机中。<strong>leader的存在避免了server之间通过通信进行同步的开销及不确定性</strong>（民主集中制了属于是）。当leader失效或与其他server断开连接时，就选出一个新的leader。</p><p>在上述方法下，Raft将整个流程分为三块：</p><ol><li>leader选举：现有leader失效必须选举出新leader</li><li>log备份：leader必须接受client传来的log，并将这些log在整个集群中进行备份，</li><li>安全性：主要安全属性为，当一个server接受了一个log条目，其他server不得对相同的索引log条目做出不同的修改，？这通过在选举机制中添加额外的限制实现。</li></ol><p>Raft节点三态：</p><p>leader：相应所有请求并转发</p><p>follower：只响应leader和candidate的请求，接受到client的请求会转发给leader</p><p>candidate：执行选举操作</p><p>Raft将时间项划分为任意长度，每段都有一个选举election头</p><p>时间项充当一个逻辑时钟 logical clock，每个server存储一个current term值，server互相通信时会叫唤current term值，当server接受到的term和自身维护的term不同时，server会使用较大的term替代当前term。如果一个leader或candidate发现其term已经过期，他会立即转入follower状态。如果一个server接受到了一个包含过期term的请求，他会拒绝该请求。（体现了一个状态动态维护，就是系统状态由整个系统维护？）</p><p>两个RPC：</p><ol><li>RequestVote：由candidate在选举期间使用</li><li>AppendEntries：由leader复制log条目及<strong>提供心跳</strong>？使用</li><li>在server中传输snapshot的rpc</li></ol><p>Server在规定时间内没有接受到rpc的回复时会进行重试</p><h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3><p>初始所有server保持follower状态，直到其接受到来自leader的有效rpc请求。leader会定期给其follower发送心跳（使用AppendEntries），当follower在一定时间内（election timeout，称为选举超时）没有接受到有效rpc请求，则其认为leader失效，开始选举流程。</p><p>一个follower转为candidate前先增加其当前的term，然后为其自己投票，然后并行地向所有其他server发送RequestVote（拉选票）。</p><p><strong>candidate胜选条件为：</strong>在同一个时间期内，收到相同集群大部分server的投票</p><p><strong>选举退出条件为：</strong></p><p>（1）成为leader。<strong>投票规则</strong></p><p>1⃣️一个server在一个时间期内只能投票给一个candidate（保证只有一个leader），并且遵循先来先投票规则（在后面会进行限制）</p><p>2⃣️candidate胜选后立即向所有其他server发送心跳，从而建立leadership，防止新的选举。当candidate接受到大部分server的选票时，就转为leader。（大部分指超过半数？）</p><p>（2）另一个server成为leader。当candidate等待投票时收到来自其他自称为leader的server发送的AppendEntry请求，则会判断leader的term和其自身的term，如果leader的term比自己大则接受请求，转向follower，否则拒绝请求，保持candidate。<strong>（log请求丢失怎么办？）</strong></p><p>（3）超过规定时间。所有candidate将其term增加，开始新一轮选举。主要产生的原因是，在同一时刻有多个candidate启动选举，这就导致了可能有多个candiadate同时发送RequestVote，收到相同的票数，没有人成为leader，这成为split vote。为了避免这种情况，Raft采用了随机超时的设置，<strong>随机地为每个candidate设置超时时间（150～300ms），这样就将同时启动的candidate岔开</strong>，避免再次出现split vote。在candidate选举开始前会设置一个random timeout，后面选举过程中就等待这个timeout超时。</p><h3 id="Log-复制"><a href="#Log-复制" class="headerlink" title="Log 复制"></a>Log 复制</h3><ol><li>leader接受到client的请求后，首先添加到其自身的log中，然后发AppendEntry给所有server，直到所有server都将新log添加完毕后，server将新条目写入其状态机，然后将结果返回给client。当某个server响应leader的AppendEntry过慢时，<strong>leader会无限次重试AppendEntry</strong>，直到server状态一致。</li></ol><p>Log复制需要保证</p><ol><li>如果不同server的log的entries有相同的index和相同的term，那么他们存储相同的指令</li><li>如果不同server的log的entries有相同的index和相同的term，那么其log的前面的内容也完全一致。</li></ol><p>leader在给follower发送AppendEntry请求时，会同时发送新log entry紧挨着的前一个entry的索引和项，follower接受到请求后会对比前一个entry的index和term，若和follower本身的不一致则拒绝添加新entry。</p><p>正常情况下，leader和follower的log是保持一致的，但是当leader失效时，旧leader的log可能有缺失，也可能包含当前leader没有的log（因为leader接受到log后首先会添加到其自身的log，然后转发给其他follower，当其失效时只有其自身log中存在对应条目，AppendEntry事务并没有提交）。</p><p>leader处理log不一致的方式是，找到follower的log与其自身log保持一致的最新位置，将follower的log从该位置之后的内容全部删除，然后将其后的内容重新发送给follower。</p><p>leader会维护每个follower的下一个同步索引（nextIndex），当leader首次掌权时，它会将所有follower的nextIndex设为leader自身log的下一个索引。leader向follower发送AppendEntry请求时，如果leader记录的nextIndex和follower自身的最新Index不一致，AppendEntry就会返回false，这时leader就会将该follower的nextIndex减1，直至AppendEntry返回true。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Raft保证leader在当选的时刻起就获得了之前term的所有log条目，而不需要在之后由其他server将这些条目转交给leader，这就保证了log只从leader流向follower。</p><p>为了实现这一点，RequestVote调用中包含了candidate的LastLogIndex和LastLogTerm，由follower判断哪个日志是最新的：</p><p>1⃣️如果两个logs的最后一个entry为不同的term，那么拥有较新term的log为最新的。</p><p>2⃣️如果两个logs的最后一个entry为相同term，那么长度更长的log是最新的。</p><p>如果follower判断自己的log比candidate的log更新，那么它会拒绝投票。</p><h4 id="处理前一任期正在提交中的log条目"><a href="#处理前一任期正在提交中的log条目" class="headerlink" title="处理前一任期正在提交中的log条目"></a>处理前一任期正在提交中的log条目</h4><p>前一个任期的leader有可能在执行log复制的过程中退出，因此即使当前任期中server的大部分都含有该log条目，leader也不应立即断定该条目已提交。</p><p>Raft要求只有当前任期leader的条目提交才使用已备份follower计数的方式来确认提交。当当前任期的条目以此方式提交时，之前任期未提交的条目就间接提交了（依赖于Log Matching Property）。</p><p>新任期的leader在复制之前任期的条目时会使用之前任期的编号（但是不是说AppendEntry发送的任期低于当前任期时会被拒绝吗？难道当前leader任期和log条目对应的任期都要分别发送？）</p><h3 id="配置切换"><a href="#配置切换" class="headerlink" title="配置切换"></a>配置切换</h3><p>主要需要保证配置切换过程中只有最多一个leader独立做决策</p><p>当follower的log远远落后于leader时（比如新加入的server或响应特别慢的server），leader会发送一个InstallSnapshot指令来将快照发送给该follower。</p><p>所有server都会产生快照</p><h3 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h3><p>客户端发出的请求都包含一个唯一序列号，状态机会记录每个client已处理的最新序列号。当leader处理完client请求未返回结果时崩溃，client会重发该请求，server就可以通过比较序列号来判断是否执行该请求，这就保证了操作的幂等性。</p><h3 id="Raft-Structure要点"><a href="#Raft-Structure要点" class="headerlink" title="Raft Structure要点"></a>Raft Structure要点</h3><ol><li>每个RPC通常使用一个单独的goroutine来处理</li><li>applyCh？单独的长期goroutine执行，sync.Cond</li><li>使用time.Sleep管理选举超时</li><li>心跳和选举超时都是用单独的goroutine执行</li><li><strong>goroutine使用共享数据和锁来进行信息传递</strong></li></ol><h3 id="Raft锁"><a href="#Raft锁" class="headerlink" title="Raft锁"></a>Raft锁</h3><p>使用sync.Cond或channel替代空循环等待</p><h3 id="实现记录"><a href="#实现记录" class="headerlink" title="实现记录"></a>实现记录</h3><ol><li>将commited的entry添加到每个peer的applyCh</li><li>5.4.1中的election restriction</li><li>重复选举可能导致错误，检查选举timer，以及避免赢得选举后立即发送heartbeats？为什么</li><li>避免检查条件的for循环无限重复，使用cond或Sleep</li></ol>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题型总结】LRU、LFU、O(1)数据结构</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/%E3%80%90%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E3%80%91LRU%E3%80%81LFU%E3%80%81O(1)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/%E3%80%90%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E3%80%91LRU%E3%80%81LFU%E3%80%81O(1)%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存 - 力扣（LeetCode）</a></p><p>单哈希+双联表，unordered_map&lt;int, list<Node>::iterator&gt;哈希，双链表可以使用自定义Node+std::list实现，list单个iterator删除不影响其他iterator</p><p><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU 缓存 - 力扣（LeetCode）</a></p><p>双哈希+双联表，unordered_map&lt;int, list<Node>::iterator&gt;存kv，unordered_map&lt;int, list<Node>&gt; 存计数器+对应链表</p><p><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值 - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>解题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>解题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题型总结】寻找重复数</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/%E3%80%90%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E3%80%91%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/%E3%80%90%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%E3%80%91%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></p><p>（1）最简单的实现：哈希表&#x2F;集合保存已经出现过的数值，遍历数组的同时只要判断该数值是否曾经出现过即可。或者排序之后判断相邻数值是否一致。</p><p>（2）对于[1~n]范围内，可以修改原数组的，可以使用原地哈希？，修改每个值x对应的下标位置的数值的符号，当修改之后对应数值仍为正数时则是出现了两次。</p><p>（3）原地置换，将数值交换到其对应下标位置下</p><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p><p>对于不可修改原数组且使用常量空间复杂度的</p><p>（1）使用二分查找 nlogn</p><p>我们使用一个循环（复杂度O(n)）为每个索引记录数组中比该索引值小的数值的数量x</p><p>可以发现比重复数值小的索引，其x值小于对应的索引值</p><p>而比重复数值大的索引，其x值大于等于对应的索引值</p><p>这满足了二分查找的二分性</p><p>（2）二进制，首先计算n个数各个二进制位对应的数量和，然后计算nums数组各个数的二进制位的对应和，比较哪些位和大，哪些位和小，以此可以分析得出重复数对应的二进制</p><p>（3）O(n)方法，快慢指针，Floyd循环判断</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>解题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>解题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 基础语法</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、输入输出"><a href="#一、输入输出" class="headerlink" title="一、输入输出"></a>一、输入输出</h3><h5 id="读取单个字符"><a href="#读取单个字符" class="headerlink" title="读取单个字符"></a>读取单个字符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">istream::get</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 示例1</span><br><span class="hljs-type">int</span> a;<br>a = cin.<span class="hljs-built_in">get</span>();<br><span class="hljs-comment">// 示例2 </span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-comment">// EOF标识文件末尾，Win Ctrl+z / Linux Ctrl+d</span><br><span class="hljs-keyword">while</span>((ch=cin.<span class="hljs-built_in">get</span>())!=EOF)&#123;<br>    cout&lt;&lt;ch;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span>&amp; c)</span></span>;<br><span class="hljs-comment">// 示例1</span><br><span class="hljs-type">char</span> a, b, c;<br>cin.<span class="hljs-built_in">get</span>(a).<span class="hljs-built_in">get</span>(b).<span class="hljs-built_in">get</span>(c); <span class="hljs-comment">// 依次输入a、b、c</span><br></code></pre></td></tr></table></figure><h5 id="读取一行字符"><a href="#读取一行字符" class="headerlink" title="读取一行字符"></a>读取一行字符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n为最大输入长度，输入char数组时最后一位计&#x27;\0&#x27;，因此实际有效位为-1</span><br><span class="hljs-comment">// delim为结束符（不包含delim）</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n, <span class="hljs-type">char</span> delim)</span></span>;<br><span class="hljs-comment">// 示例1</span><br><span class="hljs-type">char</span> ch[<span class="hljs-number">10</span>];<br>cin.<span class="hljs-built_in">get</span>(ch, <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 示例2</span><br><span class="hljs-type">char</span> ch[<span class="hljs-number">10</span>];<br>cin.<span class="hljs-built_in">get</span>(ch, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以\0结尾</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span><span class="hljs-params">(istream&amp; is, string&amp; str, <span class="hljs-type">char</span> delim)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span><span class="hljs-params">(istream&amp; is, string&amp; str)</span></span>;<br><span class="hljs-comment">// 示例1</span><br>string a;<br><span class="hljs-built_in">getline</span>(cin, a);<br></code></pre></td></tr></table></figure><h5 id="标准输入流-istream"><a href="#标准输入流-istream" class="headerlink" title="标准输入流 istream"></a>标准输入流 istream</h5><p>标准输入流使用缓冲区中空格、tab或换行符等分隔符作分割，继续读取后面的字符，若缓冲区为空则等待输入。若读取字符成功，则字符后面的分隔符会留在缓冲区中不做处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a;<span class="hljs-type">int</span> b;<span class="hljs-type">bool</span> c;string d;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;<br><span class="hljs-comment">// 读取空格（只适用字符读取）</span><br>cin&gt;&gt;noskipws;<br><span class="hljs-comment">// 不读取空格</span><br>cin&gt;&gt;skipws;<br></code></pre></td></tr></table></figure><h5 id="字符输入流-sstream"><a href="#字符输入流-sstream" class="headerlink" title="字符输入流 sstream"></a>字符输入流 sstream</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-function">std::istringstream <span class="hljs-title">var</span><span class="hljs-params">(string s)</span></span>;<br><span class="hljs-type">int</span> a; string b; <span class="hljs-type">int</span> c;<br>var &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br></code></pre></td></tr></table></figure><h5 id="格式化输出-printf"><a href="#格式化输出-printf" class="headerlink" title="格式化输出 printf"></a>格式化输出 printf</h5><table><thead><tr><th>%u</th><th>十进制无符号整数</th><th>%3d</th><th>十进制有符号整数，3表示长度，不足右对齐</th></tr></thead><tbody><tr><td>%p</td><td>指针值</td><td>%8s</td><td>字符串，数字表示字符串长度，不足则右对齐</td></tr><tr><td>%c</td><td>单个字符</td><td>%9.2f</td><td>浮点数，9表示数值总长度，2小数位数，不足右对齐</td></tr><tr><td>%e</td><td>指数形式浮点数</td><td>%g</td><td>按%e或%f中输出长度较小的形式输出</td></tr><tr><td>%o</td><td>无符号8进制整数</td><td>%x</td><td>无符号16进制整数</td></tr></tbody></table><h6 id="关于场宽"><a href="#关于场宽" class="headerlink" title="关于场宽"></a>关于场宽</h6><ul><li>字符串、整数的场宽超出声明值则按实际长度输出。浮点数场宽超出时，整数按实际长度输出，小数按说明宽度四舍五入输出。</li><li>场宽前加<code>0</code>表示不足位用0补齐，<code>%04d</code>表示输出长度小于4位时在其前面补0使其总宽度为4位。</li><li>场宽前加<code>-</code>表示左对齐。</li><li><code>%ld</code>表示输出long整数，<code>%lf</code>表示输出double浮点数。</li></ul><h3 id="二、字符串和字符数组"><a href="#二、字符串和字符数组" class="headerlink" title="二、字符串和字符数组"></a>二、字符串和字符数组</h3><h5 id="string、int、char数组互转"><a href="#string、int、char数组互转" class="headerlink" title="string、int、char数组互转"></a>string、int、char数组互转</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// string to int (C)</span><br><span class="hljs-type">int</span> a = <span class="hljs-built_in">atoi</span>(str.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-comment">// int to string (C++11)</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-comment">// string to char[]</span><br>str.<span class="hljs-built_in">data</span>();<span class="hljs-comment">// 不带&#x27;\0&#x27;</span><br>str.<span class="hljs-built_in">c_str</span>();<span class="hljs-comment">// 带&#x27;\0&#x27;</span><br><span class="hljs-built_in">strcpy_s</span>(c,s.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-comment">// char[] to string</span><br><span class="hljs-type">char</span> cstr;<br>string str=cstr;<br><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(cstr)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="char数组常用操作"><a href="#char数组常用操作" class="headerlink" title="char数组常用操作"></a>char数组常用操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> cstr[<span class="hljs-number">100</span>];<br><span class="hljs-comment">// 覆盖</span><br><span class="hljs-built_in">sprintf_s</span>(cstr, <span class="hljs-string">&quot;test%d.jpg&quot;</span>, num);<br><span class="hljs-comment">// 拷贝</span><br><span class="hljs-built_in">strcpy_s</span>(cstr1, cstr2);<br><span class="hljs-type">char</span>* cstr1=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cstr2)+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(cstr1, <span class="hljs-built_in">strlen</span>(cstr2)+<span class="hljs-number">1</span>, str2);<br><span class="hljs-comment">// 连接（需要注意cstr剩余长度要大于cstr2长度）</span><br><span class="hljs-built_in">strcat_s</span>(cstr, cstr2);<br><span class="hljs-comment">// 比较（相等返回0，str1&gt;str2返回正，否则返回负）</span><br><span class="hljs-built_in">strcmp_s</span>(str1,str2);<br><span class="hljs-comment">// 取长度（&#x27;\0&#x27;前）</span><br><span class="hljs-built_in">strlen</span>(str);<br><br><span class="hljs-comment">// 大小写转换、字符类型判断</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">toupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tolower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isalpha</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isdigit</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isalnum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>; <span class="hljs-comment">// 是字母或数字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isspace</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// string 可以使用很多vector的操作，类似vector&lt;char&gt;</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="三、内存分配"><a href="#三、内存分配" class="headerlink" title="三、内存分配"></a>三、内存分配</h3><ul><li>需要注意<code>sizeof</code>是运算符</li><li><code>memset</code>是对每个字节初始化，而不是对数组元素初始化。如执行<code>memset(dp, 1, sizeof(dp))</code>，最后得出的每个 int 值为<code>00000001 00000001 00000001 00000001</code>，转化为十进制后不为1。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">memset</span> <span class="hljs-params">( <span class="hljs-type">void</span> * ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num )</span></span>;<br><span class="hljs-comment">// 示例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br><br><span class="hljs-comment">// 自增初始化器，初始值为val</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">iota</span> <span class="hljs-params">(ForwardIterator first, ForwardIterator last, T val)</span></span>;<br><span class="hljs-comment">// 示例</span><br><span class="hljs-built_in">iota</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="四、lambda表达式"><a href="#四、lambda表达式" class="headerlink" title="四、lambda表达式"></a>四、lambda表达式</h3><p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">https://www.cnblogs.com/jimodetiantang/p/9016826.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// cmp比较函数</span><br>[](<span class="hljs-type">const</span> string &amp; a, <span class="hljs-type">const</span> string &amp; b) &#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;<br></code></pre></td></tr></table></figure><h3 id="五、数学"><a href="#五、数学" class="headerlink" title="五、数学"></a>五、数学</h3><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需要确定象限（指定起点）时使用atan2（取值范围 -Π~Π ）</span><br><span class="hljs-comment">// 正常求夹角（无起点终点）使用atan（取值范围 -Π/2~Π/2） </span><br></code></pre></td></tr></table></figure><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20211216110706076.png" alt="image-20211216110706076"></p><h3 id="六、函数指针-待补充"><a href="#六、函数指针-待补充" class="headerlink" title="六、函数指针 待补充"></a>六、函数指针 待补充</h3>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 基础数据结构</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1-vector"><a href="#1-vector" class="headerlink" title="(1) vector"></a>(1) vector</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span> <span class="hljs-params">(InputIterator first, InputIterator last)</span></span>; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span> <span class="hljs-params">(size_type n, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><span class="hljs-comment">// 批量删除，返回删除之后vector最后有效元素的迭代器，但不改变vector大小</span><br><span class="hljs-function">ForwardIterator <span class="hljs-title">remove</span> <span class="hljs-params">(ForwardIterator first, ForwardIterator last, <span class="hljs-type">const</span> T&amp; val)</span></span>;<br><span class="hljs-comment">// 插入</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, size_type n, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, InputIterator first, InputIterator last)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">emplace</span> <span class="hljs-params">(const_iterator position, Args&amp;&amp;... args)</span></span>;<br><span class="hljs-comment">// 删除</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator position)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator first, const_iterator last)</span></span>;<br><span class="hljs-comment">// 交换单个元素</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span> <span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">T <span class="hljs-title">c</span><span class="hljs-params">(std::move(a))</span></span>; a=std::<span class="hljs-built_in">move</span>(b); b=std::<span class="hljs-built_in">move</span>(c);<br>&#125;<br><span class="hljs-comment">// 交换整体</span><br>v1.<span class="hljs-built_in">swap</span>(v2);<br><span class="hljs-comment">// 反向迭代器，支持迭代器构建</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator ri = a.<span class="hljs-built_in">rbegin</span>(); ri != a.<span class="hljs-built_in">rend</span>(); ri++) &#123;<br>    cout &lt;&lt; *ri &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 迭代器初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(v_old.begin(),v_old.end())</span></span>;<br><br><span class="hljs-comment">// emplace_back 和 push_back 区别</span><br><span class="hljs-comment">// push_back: 先构造临时对象，再调用拷贝构造函数将临时对象拷贝到vector末尾</span><br><span class="hljs-comment">// emplace_back: 直接在末尾构造，不拷贝</span><br></code></pre></td></tr></table></figure><h3 id="2-set（有序红黑树集合）-amp-unordered-set（无序哈希集合）"><a href="#2-set（有序红黑树集合）-amp-unordered-set（无序哈希集合）" class="headerlink" title="(2) set（有序红黑树集合） &amp; unordered_set（无序哈希集合）"></a>(2) set（有序红黑树集合） &amp; unordered_set（无序哈希集合）</h3><p>set 红黑树实现，时间复杂度O(logn)</p><p>unordered_set 哈希表实现，时间复杂度O(1)，最坏O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 查找</span><br><span class="hljs-function">iterator <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-function">size_type <span class="hljs-title">count</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// （仅set）返回值大于等于的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">lower_bound</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// （仅set）返回值小于等于的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">upper_bound</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// 支持迭代器，支持迭代器构建</span><br><span class="hljs-built_in">begin</span>();<span class="hljs-built_in">end</span>();<br><span class="hljs-built_in">rbegin</span>();<span class="hljs-built_in">rend</span>(); <span class="hljs-comment">// 仅set支持</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v:set);<br></code></pre></td></tr></table></figure><h3 id="3-queue-amp-deque-amp-priority-queue-heaps"><a href="#3-queue-amp-deque-amp-priority-queue-heaps" class="headerlink" title="(3) queue &amp; deque &amp; priority_queue(heaps)"></a>(3) queue &amp; deque &amp; priority_queue(heaps)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// queue，不支持迭代器，不支持迭代器构建</span><br><span class="hljs-function">reference&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">reference&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">push</span>();<br><span class="hljs-built_in">emplace</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// deque（queue+vector），支持顺序访问，支持迭代器，支持迭代器构建</span><br><span class="hljs-built_in">front</span>();<br><span class="hljs-built_in">back</span>();<br><span class="hljs-built_in">push_back</span>();<br><span class="hljs-built_in">push_front</span>();<br><span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">pop_front</span>();<br><span class="hljs-keyword">operator</span>[];<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// priority_queue，不支持迭代器，支持迭代器构建</span><br><span class="hljs-built_in">push</span>();<br><span class="hljs-built_in">top</span>();<br><span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// greater&lt;int&gt; 升序队列，小根堆 | less&lt;int&gt; 降序队列，大根堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br><br><span class="hljs-comment">// 自定义比较函数，返回false则a比b优先级高，排在前面</span><br><br><span class="hljs-comment">// (1) 定义struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a&lt;b;<br>    &#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp&gt; pq;<br><br><span class="hljs-comment">// (2) 定义lambda表达式</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b) &#123;<span class="hljs-keyword">return</span> a &lt; b; &#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br></code></pre></td></tr></table></figure><h3 id="4-stack"><a href="#4-stack" class="headerlink" title="(4) stack"></a>(4) stack</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不支持迭代器，不支持迭代器构建</span><br><span class="hljs-built_in">top</span>();<br><span class="hljs-built_in">push</span>(val);<br><span class="hljs-built_in">emplace</span>(val); <span class="hljs-comment">// C++11</span><br><span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure><h3 id="5-map（红黑树有序）-amp-unordered-map（哈希无序）"><a href="#5-map（红黑树有序）-amp-unordered-map（哈希无序）" class="headerlink" title="(5) map（红黑树有序） &amp; unordered_map（哈希无序）"></a>(5) map（红黑树有序） &amp; unordered_map（哈希无序）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// map，支持迭代器，支持迭代器构建，返回pair</span><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; data: mp)&#123;<br>cout&lt;&lt;data.first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;data.second&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-built_in">find</span>(key);<br><span class="hljs-built_in">count</span>(key);<br><span class="hljs-built_in">lower_bound</span>(key);<br><span class="hljs-built_in">upper_bound</span>(key);<br><span class="hljs-comment">// unordered_map，不支持反向迭代器，支持迭代器初始化</span><br></code></pre></td></tr></table></figure><h3 id="6-list"><a href="#6-list" class="headerlink" title="(6) list"></a>(6) list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 双向链表</span><br><span class="hljs-comment">// 支持全部迭代器，支持迭代器初始化</span><br><span class="hljs-built_in">begin</span>();<span class="hljs-built_in">end</span>();<span class="hljs-built_in">rbegin</span>();<span class="hljs-built_in">rend</span>();<br><span class="hljs-comment">// 取首尾</span><br><span class="hljs-built_in">front</span>();<span class="hljs-built_in">back</span>();<br><span class="hljs-comment">// 首位插入删除</span><br><span class="hljs-built_in">emplace_front</span>(); <span class="hljs-comment">//C++11</span><br><span class="hljs-built_in">emplace_back</span>(); <span class="hljs-comment">//C++11</span><br><span class="hljs-built_in">push_front</span>();<br><span class="hljs-built_in">push_back</span>();<br><span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// 迭代器插入删除</span><br><span class="hljs-built_in">insert</span>(it,[n], val);<br><span class="hljs-built_in">erase</span>(begin,[end]);<br><span class="hljs-comment">// 按值删除</span><br>l.<span class="hljs-built_in">remove</span>(val);<br><span class="hljs-comment">// 传入bool函数，返回true则删除</span><br>l.<span class="hljs-built_in">remove_if</span>(func);<br><span class="hljs-comment">// 删除重复值，将不重复值移到前面重复值的位置，返回新end()，改变size。支持bool函数判断。</span><br>l.<span class="hljs-built_in">unique</span>([func]);<br><span class="hljs-comment">// 元素跨list剪切移动</span><br>l1.<span class="hljs-built_in">splice</span>(l1it, l2); <span class="hljs-comment">// 将l2中所有元素移到l1it位置，原l1it接在l2元素末尾，l2清空</span><br>l1.<span class="hljs-built_in">splice</span>(l1it, l2, l2it); <span class="hljs-comment">// 只移动l2it元素</span><br>l1.<span class="hljs-built_in">splice</span>(l1it, l2, l2it1, l2it2); <span class="hljs-comment">// 移动l2it1~l2it2间的元素</span><br><span class="hljs-comment">// 排序</span><br>l.<span class="hljs-built_in">sort</span>([func]);<br><span class="hljs-comment">// 有序合并（两个list必须提前排序，l2会清空）</span><br>l1.<span class="hljs-built_in">merge</span>(l2);<br></code></pre></td></tr></table></figure><h3 id="6-multiset（有序红黑树多集，允许重复key）"><a href="#6-multiset（有序红黑树多集，允许重复key）" class="headerlink" title="(6) multiset（有序红黑树多集，允许重复key）"></a>(6) multiset（有序红黑树多集，允许重复key）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建，支持所有迭代器，支持迭代器初始化</span><br>multiset&lt;<span class="hljs-type">int</span>&gt; ms;<br><span class="hljs-comment">// 插入</span><br>ms.<span class="hljs-built_in">insert</span>();<br><span class="hljs-comment">// 删除 根据迭代器删除、根据值删除、根据迭代器范围删除</span><br><span class="hljs-function">iterator  <span class="hljs-title">erase</span> <span class="hljs-params">(const_iterator position)</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">erase</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><span class="hljs-function">iterator  <span class="hljs-title">erase</span> <span class="hljs-params">(const_iterator first, const_iterator last)</span></span>;<br><span class="hljs-comment">// 查找 返回迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">iterator       <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="7-方法总结"><a href="#7-方法总结" class="headerlink" title="(7) 方法总结"></a>(7) 方法总结</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// find();count(); 用于set和map</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// sort，必须支持随机访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;<br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)&#123;<span class="hljs-keyword">return</span> a&lt;b;&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// reverse，必须支持双向迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span> <span class="hljs-params">(BidirectionalIterator first, BidirectionalIterator last)</span></span>;<br><span class="hljs-function">OutputIterator <span class="hljs-title">copy</span> <span class="hljs-params">(InputIterator first, InputIterator last, OutputIterator result)</span></span>;<br><span class="hljs-comment">// 将from到to的值累加到init</span><br><span class="hljs-function">itn <span class="hljs-title">accumulate</span><span class="hljs-params">(Iterator from, Iterator to, <span class="hljs-type">int</span> init)</span></span>;<br><br><span class="hljs-comment">// 返回第一个大于value的位置</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br><br><span class="hljs-comment">// 返回第一个大于等于value的位置</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">upper_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><h3 id="8-使用"><a href="#8-使用" class="headerlink" title="(8) 使用"></a>(8) 使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 数组src，indices，根据src的值排序indices</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; src; <span class="hljs-comment">// 原数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indices</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 索引数组</span><br><span class="hljs-built_in">iota</span>(indices.<span class="hljs-built_in">begin</span>(),indices.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br><span class="hljs-built_in">sort</span>(indices.<span class="hljs-built_in">begin</span>(),indices.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> src[i][<span class="hljs-number">0</span>]&lt;src[j][<span class="hljs-number">0</span>];&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 常用算法</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastPow</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            ans *= a;<br>        &#125;<br>        a *= a;<br>        n&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="大数相乘取模（快速乘）"><a href="#大数相乘取模（快速乘）" class="headerlink" title="大数相乘取模（快速乘）"></a>大数相乘取模（快速乘）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastMulti</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; a &gt; <span class="hljs-number">0</span>;a&gt;&gt;=<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (a &amp; <span class="hljs-number">1</span>) &#123;<br>ans += b;<br>&#125;<br>b &lt;&lt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最长递增子序列（一维dp、贪心-二分）"><a href="#最长递增子序列（一维dp、贪心-二分）" class="headerlink" title="最长递增子序列（一维dp、贪心+二分）"></a>最长递增子序列（一维dp、贪心+二分）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1 DP，dp[i]记录每个位置的最长递增长度</span><br><span class="hljs-comment">// 2 贪心 + 二分查找，目的是使每个长度的子序列末尾元素最小，因此遍历数组时在已有长度区间内二分查找当前值，使用当前值替换第一个比当前值大的</span><br></code></pre></td></tr></table></figure><h4 id="最长公共子序列（区间dp）"><a href="#最长公共子序列（区间dp）" class="headerlink" title="最长公共子序列（区间dp）"></a>最长公共子序列（区间dp）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间dp，dp[i][j]代表区间i到j最长递增子序列长度</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text1.<span class="hljs-built_in">length</span>(), n = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">path</span><span class="hljs-params">(min(m, n) + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                    path[dp[i][j] - <span class="hljs-number">1</span>] = text1[i - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印最长子序列，还可以从dp[m][n]通过dp反向推导打印</span><br>        <span class="hljs-function">string <span class="hljs-title">p</span><span class="hljs-params">(path.begin(), path.begin() + dp[m][n])</span></span>;<br>        cout&lt;&lt;p&lt;&lt;endl;<br><br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二分查找（红蓝指针版）"><a href="#二分查找（红蓝指针版）" class="headerlink" title="二分查找（红蓝指针版）"></a>二分查找（红蓝指针版）</h4><p><a href="https://www.bilibili.com/video/BV1d54y1q7k7?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1d54y1q7k7?spm_id_from=333.999.0.0</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// l = blue = 小于某个数的最大值下标</span><br><span class="hljs-comment">// r = red = 大于某个数的最小值下标</span><br><br><span class="hljs-comment">// 例如找小于k的最大值下标，若要找k的下标，则search(nums, k+1)即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-comment">// 初始化为有效下标范围之外</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (nums[mid] &lt; k) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最大公因数（辗转相除法）"><a href="#最大公因数（辗转相除法）" class="headerlink" title="最大公因数（辗转相除法）"></a>最大公因数（辗转相除法）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (a % b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> b;<br><span class="hljs-comment">// a&lt;b则交换位置,a&gt;b则b&gt;a%b</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 求最小公倍数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">gcd</span>(a, b);<br><span class="hljs-keyword">return</span> a * b / c;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求众数（摩尔投票法）"><a href="#求众数（摩尔投票法）" class="headerlink" title="求众数（摩尔投票法）"></a>求众数（摩尔投票法）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMode</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> candidate = INT_MAX;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : nums) &#123;<br><span class="hljs-keyword">if</span> (num == candidate) cnt++;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (--cnt == <span class="hljs-number">0</span>) &#123;<br>candidate = num;<br>cnt = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> candidate;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速求平方根（牛顿迭代法）"><a href="#快速求平方根（牛顿迭代法）" class="headerlink" title="快速求平方根（牛顿迭代法）"></a>快速求平方根（牛顿迭代法）</h4><p>n次近似值<code>x(n)=x(n-1)-f(x)/f&#39;(x)</code>，求平方根即求<code>f(x)=x*x - n = 0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> n)</span> </span>&#123;<br><span class="hljs-type">double</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">fabs</span>(x * x - n) &gt; <span class="hljs-number">0.5</span>) &#123;<br>x = (x + (n / x)) / <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求单侧第一个比当前值大-x2F-小的数（单调栈）"><a href="#求单侧第一个比当前值大-x2F-小的数（单调栈）" class="headerlink" title="求单侧第一个比当前值大&#x2F;小的数（单调栈）"></a>求单侧第一个比当前值大&#x2F;小的数（单调栈）</h4><h4 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h4><p>N个人围成环，人编号<strong>从0开始</strong>，数到第M个人出局，求最后留在场上的人的编号</p><p>f(N,M)表示N个人M时的胜者编号，使胜者f(N-1,M)向后移动M位，相当于模拟队列<br>$$<br>f(N, M) &#x3D; (f(N-1,M)+M)%N<br>$$</p><h4 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. N个物体选或不选<br>int upper_bound = 1&lt;&lt;N;<br>2. N个物体ANN(一般不会用)<br></code></pre></td></tr></table></figure><h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0.</span> 二进制<span class="hljs-type">int</span>声明以<span class="hljs-number">0b</span>开头<br><span class="hljs-type">int</span> a = <span class="hljs-number">0b00011100</span>; <span class="hljs-comment">// 27</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">0b00010111</span>; <span class="hljs-comment">// 23</span><br><span class="hljs-number">1.</span> 按位与<br>a &amp; b <span class="hljs-comment">// 0b00010100 即20，判断时不能使用==1</span><br><span class="hljs-number">2.</span> 按位或<br>a | b <span class="hljs-comment">// 0b00011111;</span><br><span class="hljs-number">3.</span> 按位异或<br>a ^ b <span class="hljs-comment">// 0b00001011;</span><br></code></pre></td></tr></table></figure><h4 id="快排（递归、迭代实现，重点在于partition函数）"><a href="#快排（递归、迭代实现，重点在于partition函数）" class="headerlink" title="快排（递归、迭代实现，重点在于partition函数）"></a>快排（递归、迭代实现，重点在于partition函数）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span> pivot = v[l];<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-keyword">while</span> (v[r] &gt; pivot &amp;&amp; r &gt; l) --r;<br>v[l] = v[r];<br><span class="hljs-keyword">while</span> (v[l] &lt;= pivot &amp;&amp; r &gt; l) ++l;<br>v[r] = v[l];<br>&#125;<br>v[l] = pivot;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; stk;<br>stk.<span class="hljs-built_in">emplace</span>(l, r);<br><span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span> p = stk.<span class="hljs-built_in">front</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> m = <span class="hljs-built_in">partition</span>(v, p.first, p.second);<br><span class="hljs-keyword">if</span> (p.first &lt; m - <span class="hljs-number">1</span>) stk.<span class="hljs-built_in">emplace</span>(p.first, m - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (p.second &gt; m + <span class="hljs-number">1</span>) stk.<span class="hljs-built_in">emplace</span>(m+<span class="hljs-number">1</span>, p.second);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 进阶数据结构</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++11%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一、字典树-x2F-前缀树-Trie"><a href="#一、字典树-x2F-前缀树-Trie" class="headerlink" title="一、字典树&#x2F;前缀树 Trie"></a>一、字典树&#x2F;前缀树 Trie</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-type">bool</span> isEnd;<br>vector&lt;Trie*&gt; child;<br><span class="hljs-built_in">Trie</span>() &#123;<br><span class="hljs-keyword">this</span>-&gt;child = <span class="hljs-built_in">vector</span>&lt;Trie*&gt;(<span class="hljs-number">26</span>, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">this</span>-&gt;isEnd = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span> </span>&#123;<br>Trie* node = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">length</span>(); i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> p;<br><span class="hljs-keyword">if</span> (node-&gt;child[p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;<br>node-&gt;child[p] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>&#125;<br>node = node-&gt;child[p];<br>&#125;<br><span class="hljs-keyword">if</span> (node) node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string s)</span> </span>&#123;<br>Trie* node = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">length</span>(); i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> p;<br><span class="hljs-keyword">if</span> ((node = node-&gt;child[p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]) == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (node) <span class="hljs-keyword">return</span> node-&gt;isEnd;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string s)</span> </span>&#123;<br>Trie* node = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">length</span>(); i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> p;<br><span class="hljs-keyword">if</span> ((node = node-&gt;child[p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]) == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (node) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// void delete(string s); 使用lazy标记，记录每个节点的引用次数，引用为0则删除</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><h3 id="二、线段树（区间修改、区间查询）"><a href="#二、线段树（区间修改、区间查询）" class="headerlink" title="二、线段树（区间修改、区间查询）"></a>二、线段树（区间修改、区间查询）</h3><p>数据结构：</p><p>修改操作：（1）当前节点i区间被修改区间完全包含（2）当前区间右子区间与修改区间有交集（3）当前区间左子区间与修改区间有交集</p><h4 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SegmentTree</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; _data) :<span class="hljs-built_in">data</span>(_data) &#123;<br>tree = <span class="hljs-built_in">vector</span>&lt;Node&gt;(<span class="hljs-number">4</span> * data.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll i, ll l, ll r)</span> </span>&#123;<br>tree[i].l = l;<br>tree[i].r = r;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br><span class="hljs-comment">// 这里注意r是实际数据位置，i是该数据在线段树的节点位置</span><br>tree[i].ans = data[r];<br>tree[i].lazy = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(i &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br><span class="hljs-built_in">build</span>(i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>tree[i].lazy = <span class="hljs-number">0</span>;<br>tree[i].ans = tree[i &lt;&lt; <span class="hljs-number">1</span>].ans + tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].ans;<br>&#125;<br><br><span class="hljs-comment">// i 是当前节点位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll i, ll l, ll r, ll k)</span> </span>&#123;<br><span class="hljs-comment">// 当前区间被完全包含</span><br><span class="hljs-keyword">if</span> (tree[i].r &lt;= r &amp;&amp; tree[i].l &gt;= l) &#123;<br>tree[i].ans += k * (tree[i].r - tree[i].l + <span class="hljs-number">1</span>);<br>tree[i].lazy += k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (tree[i].lazy != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">pushdown</span>(i);<br>&#125;<br><span class="hljs-comment">// 当前区间右子区间有交集</span><br><span class="hljs-keyword">if</span> (tree[i &lt;&lt; <span class="hljs-number">1</span>].r &gt;= l) &#123;<br><span class="hljs-built_in">change</span>(i &lt;&lt; <span class="hljs-number">1</span>, l, r, k);<br>&#125;<br><span class="hljs-comment">// 当前区间左子区间有交集</span><br><span class="hljs-keyword">if</span> (tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].l &lt;= r) &#123;<br><span class="hljs-built_in">change</span>(i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, k);<br>&#125;<br><br>tree[i].ans = tree[i &lt;&lt; <span class="hljs-number">1</span>].ans + tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].ans;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(ll i, ll l, ll r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tree[i].r &lt;= r &amp;&amp; tree[i].l &gt;= l) &#123;<br><span class="hljs-keyword">return</span> tree[i].ans;<br>&#125;<br><span class="hljs-keyword">if</span> (tree[i].lazy != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">pushdown</span>(i);<br>&#125;<br>ll t = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 当前区间右子区间有交集</span><br><span class="hljs-keyword">if</span> (tree[i &lt;&lt; <span class="hljs-number">1</span>].r &gt;= l) &#123;<br>t += <span class="hljs-built_in">ask</span>(i &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>&#125;<br><span class="hljs-comment">// 当前区间左子区间有交集</span><br><span class="hljs-keyword">if</span> (tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].l &lt;= r) &#123;<br>t += <span class="hljs-built_in">ask</span>(i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-comment">// 下传lazy标记</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(ll i)</span> </span>&#123;<br>tree[i &lt;&lt; <span class="hljs-number">1</span>].lazy += tree[i].lazy;<br>tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].lazy += tree[i].lazy;<br>ll mid = (tree[i].l + tree[i].r) &gt;&gt; <span class="hljs-number">1</span>;<br>tree[i &lt;&lt; <span class="hljs-number">1</span>].ans += tree[i].lazy * (mid - tree[i &lt;&lt; <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>); <span class="hljs-comment">// mid-l+1</span><br>tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].ans += tree[i].lazy * (tree[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].r - mid); <span class="hljs-comment">// r-(mid+1)+1==r-mid</span><br>tree[i].lazy = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>ll l, r, lazy, ans;<br>&#125;;<br>vector&lt;Node&gt; tree;<br>vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/record/72579092">https://www.luogu.com.cn/record/72579092</a></p><p>讲解：<a href="https://www.bilibili.com/video/BV1yF411p7Bt?spm_id_from=444.41.header_right.fav_list.click">https://www.bilibili.com/video/BV1yF411p7Bt?spm_id_from=444.41.header_right.fav_list.click</a></p><h4 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h4><p>注意判断区间重叠的判断方式，使用静态固定长度的判断方法在<a href="https://leetcode.cn/problems/range-module/submissions/">715. Range 模块 - 力扣（LeetCode）</a>会超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> ans, lazy;<br>        <span class="hljs-type">int</span> lb, rb;<br>        Node* lp, * rp;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _lb, <span class="hljs-type">int</span> _rb) :<span class="hljs-built_in">lb</span>(_lb), <span class="hljs-built_in">rb</span>(_rb), <span class="hljs-built_in">lp</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">rp</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">ans</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">lazy</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    &#125;;<br><br>    Node* root;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = (node-&gt;lb + node-&gt;rb) &gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (node-&gt;lp == <span class="hljs-literal">nullptr</span>) node-&gt;lp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;lb, m);<br>        <span class="hljs-keyword">if</span> (node-&gt;rp == <span class="hljs-literal">nullptr</span>) node-&gt;rp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(m + <span class="hljs-number">1</span>, node-&gt;rb);<br><br>        <span class="hljs-keyword">if</span> (node-&gt;lazy == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (node-&gt;lazy == <span class="hljs-number">1</span>) &#123;<br>            node-&gt;lp-&gt;ans = m - node-&gt;lb + <span class="hljs-number">1</span>;<br>            node-&gt;rp-&gt;ans = node-&gt;rb - m;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;lp-&gt;ans = node-&gt;rp-&gt;ans = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        node-&gt;lp-&gt;lazy = node-&gt;rp-&gt;lazy = node-&gt;lazy;<br>        node-&gt;lazy = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(Node* node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= node-&gt;lb &amp;&amp; node-&gt;rb &lt;= r) &#123;<br>            node-&gt;ans = val == <span class="hljs-number">1</span> ? node-&gt;rb - node-&gt;lb + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            node-&gt;lazy = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">pushdown</span>(node);<br><br>        <span class="hljs-type">int</span> mid = (node-&gt;lb + node-&gt;rb) &gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (r &lt;= mid) <span class="hljs-built_in">change</span>(node-&gt;lp, l, r, val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; mid) <span class="hljs-built_in">change</span>(node-&gt;rp, l, r, val);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">change</span>(node-&gt;lp, l, r, val);<br>            <span class="hljs-built_in">change</span>(node-&gt;rp, l, r, val);<br>        &#125;<br><br>        node-&gt;ans = node-&gt;lp-&gt;ans + node-&gt;rp-&gt;ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node* node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= node-&gt;lb &amp;&amp; node-&gt;rb &lt;= r) <span class="hljs-keyword">return</span> node-&gt;ans;<br><br>        <span class="hljs-built_in">pushdown</span>(node);<br><br>        <span class="hljs-type">int</span> mid = (node-&gt;lb + node-&gt;rb) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (r &lt;= mid) ans += <span class="hljs-built_in">query</span>(node-&gt;lp, l, r);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; mid) ans += <span class="hljs-built_in">query</span>(node-&gt;rp, l, r);<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans += <span class="hljs-built_in">query</span>(node-&gt;lp, l, r);<br>            ans += <span class="hljs-built_in">query</span>(node-&gt;rp, l, r);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-built_in">change</span>(root, l, r, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-built_in">change</span>(root, l, r, <span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(root, l, r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三、并查集（单个元素加入集合，集合合并），最小生成树Kruskal算法"><a href="#三、并查集（单个元素加入集合，集合合并），最小生成树Kruskal算法" class="headerlink" title="三、并查集（单个元素加入集合，集合合并），最小生成树Kruskal算法"></a>三、并查集（单个元素加入集合，集合合并），最小生成树Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Union</span>&#123;<br>    <span class="hljs-comment">// Hash实现</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; fa;<br>  unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; rank;<br><span class="hljs-comment">// 数组实现，要求插入集合的元素处在1~n的固定范围</span><br>    <span class="hljs-comment">// vector&lt;int&gt; fa;</span><br>    <span class="hljs-comment">// Union(int n)&#123;</span><br>    <span class="hljs-comment">//     fa = vector&lt;int&gt;(n, 0);</span><br>    <span class="hljs-comment">//     iota(fa.begin(), fa.end(), 0);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> x == fa[x] ? x : <span class="hljs-built_in">find</span>(fa[x]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br>      <span class="hljs-keyword">if</span>(rank[fx] &lt; rank[fy])&#123;<br>          fa[fx] = fy;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          fa[fy] = fx;<br>          <span class="hljs-keyword">if</span>(rank[fx] == rank[fy]) rank[fx]++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isolate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        fa[x]=x;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>isolate方法参考LeetCode 2092题解：</p><p><a href="https://leetcode-cn.com/problems/find-all-people-with-secret/solution/5941c-bing-cha-ji-yi-miao-liao-you-shi-y-x8s9/">https://leetcode-cn.com/problems/find-all-people-with-secret/solution/5941c-bing-cha-ji-yi-miao-liao-you-shi-y-x8s9/</a></p></li></ul><h3 id="四、树状数组（求动态前缀和单点修改，区间查询）"><a href="#四、树状数组（求动态前缀和单点修改，区间查询）" class="headerlink" title="四、树状数组（求动态前缀和单点修改，区间查询）"></a>四、树状数组（求动态前缀和单点修改，区间查询）</h3><ul><li>lowbit作用为取到x的二进制中最低位1对应的数，<code>lowbit = x &amp; (-x)</code>（即<code>lowbit = x &amp; (~x + 1)</code>，按位或+1即求补码)</li><li>去除二进制最低位1可用 n &amp; (n-1)</li><li><strong>下标从1开始</strong></li><li>单点更新：子节点到父节点快速索引，只需要将二进制加上lowbit即可，因此单点修改时可快速修改所有父节点。</li><li>前缀和查询：每次都减去lowbit，即可找到同一层所有节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        ans += tree[x];<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>        <span class="hljs-comment">// 因为lowbit设计，会提前退出，只遍历最高层，比如4=100，4-lowbit(4)=0就退出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x &lt;= n)&#123;<br>        tree[x]+=val;<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>教程：<a href="https://www.bilibili.com/video/BV1Hz411v7XC?p=2">https://www.bilibili.com/video/BV1Hz411v7XC?p=2</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞定环境配置</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="后端环境"><a href="#后端环境" class="headerlink" title="后端环境"></a>后端环境</h3><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><p>官网 | <a href="https://www.oracle.com/java/technologies/downloads/#java8">Java Downloads | Oracle</a></p><p>Step1 解压JDK并移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf jdk-8u321-linux-x64.tar.gz<br><span class="hljs-built_in">mv</span> jdk1.8.0_321 /usr/local/java8<br></code></pre></td></tr></table></figure><p>Step2 编辑配置文件，注意替换javahome位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># root默认/etc/profile，非root可修改~/.bashrc</span><br>vim /etc/profile<br><br><span class="hljs-comment"># 在配置文件结尾加入以下内容</span><br><br><span class="hljs-comment"># jdk1.8.0</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java8<br><span class="hljs-built_in">export</span> JRE_HOME=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-comment"># 应用配置文件</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>Step3 验证安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version<br>javac -version<br></code></pre></td></tr></table></figure><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><p>官网 | <a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a></p><p>Step1 解压maven并移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br>tar -zxvf apache-maven-3.8.5-bin.tar.gz<br><span class="hljs-built_in">mv</span> apache-maven-3.8.5 /usr/local/<br></code></pre></td></tr></table></figure><p>Step2 编辑配置文件，在配置文件中添加maven路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑配置文件，默认/etc/profile，如果非root可以修改.bashrc文件，下面的source也替换为.bashrc</span><br>vim /etc/profile<br><br><span class="hljs-comment"># 添加以下内容</span><br><br><span class="hljs-comment"># maven-3.8.4</span><br><span class="hljs-built_in">export</span> MAVEN_HOME=/usr/local/apache-maven-3.8.4<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$&#123;MAVEN_HOME&#125;</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-comment"># 应用配置文件</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>Step3 检查配置情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn -v<br></code></pre></td></tr></table></figure><p>相关问题汇总</p><p><a href="https://www.cnblogs.com/sigm/p/6035155.html">使用IntelliJ IDEA 配置Maven（入门） - 竹亭 - 博客园</a></p><p><a href="https://blog.csdn.net/ryelqy/article/details/80363274">解决IDEA中maven导入jar包 - ryelqy的博客 - CSDN博客</a></p><p><a href="https://blog.csdn.net/shuzhe66/article/details/45009175">Maven通俗讲解 - 三向板砖 - CSDN博客</a></p><p><a href="https://www.cnblogs.com/tangshengwei/p/6341462.html">Eclipse上Maven环境配置使用 (全) - 唐胜伟 - 博客园</a></p><h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><p>官网 | <a href="https://tomcat.apache.org/download-80.cgi">Apache Tomcat® - Apache Tomcat 8 Software Downloads</a></p><p>Step1 解压tomcat，并移动到对应位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf apache-tomcat-8.5.75.tar.gz<br><span class="hljs-built_in">mv</span> apache-tomcat-8.5.75 /usr/local/<br></code></pre></td></tr></table></figure><p>Step2 修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑配置文件，默认/etc/profile，如果非root可以修改.bashrc文件，下面的source也替换为.bashrc</span><br>vim /etc/profile<br><br><span class="hljs-comment"># 添加以下内容，保存退出</span><br><br><span class="hljs-comment"># tomcat</span><br><span class="hljs-built_in">export</span> TOMCAT_HOME=/usr/local/apache-tomcat-8.5.75<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$&#123;TOMCAT_HOME&#125;</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-comment"># 应用配置文件</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>Step3 配置daemon访问，参考<a href="https://www.freesion.com/article/3569575843/">https://www.freesion.com/article/3569575843/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local/apache-tomcat-8.5.75/bin<br>tar -zxvf commons-daemon-native.tar.gz<br><span class="hljs-built_in">cd</span> commons-daemon-1.2.4-native-src/unix/<br><span class="hljs-comment"># 注意替换-with-java路径</span><br>./configure --with-java=/usr/local/jdk1.8.0_321<br>make<br><span class="hljs-built_in">cp</span> jsvc /usr/local/apache-tomcat-8.5.75/bin/<br></code></pre></td></tr></table></figure><p>Step4 开启Linux服务器8080端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Step1 查看已开启端口</span><br>firewall-cmd --zone=public --list-ports<br><span class="hljs-comment"># Step2 将8080加入防火墙public区域</span><br>firewall-cmd --zone=public --add-port=8080/tcp --permanent<br><span class="hljs-comment"># Step3 更新防火墙规则</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>Step5 运行tomcat服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前台运行</span><br>deamon.sh run<br><span class="hljs-comment"># 后台运行</span><br>daemon.sh start<br><span class="hljs-comment"># 停止</span><br>daemon.sh stop<br><span class="hljs-comment"># log位置</span><br>/usr/local/apache-tomcat-8.5.75/logs/<br><span class="hljs-comment"># 查看log</span><br>tial -n 100 /usr/local/apache-tomcat-8.5.75/logs/catlina-daemon.out<br><span class="hljs-comment"># war包存放位置</span><br>/usr/local/apache-tomcat-8.5.75/webapps/<br><span class="hljs-comment"># 缓存位置（遇到403、500等无法启动问题可以尝试删除缓存中Catlilna文件夹）</span><br>/usr/local/apache-tomcat-8.5.75/work/<br></code></pre></td></tr></table></figure><p>Step6 开启阿里云端口：阿里云控制台→云服务器ECS→网络与安全→安全组→选择对应安全组进入规则配置，选择手动添加开放对应端口，授权对象选择0.0.0.0&#x2F;0开放给所有IP访问</p><p><img src="https://tuchuang-1258627244.cos.ap-nanjing.myqcloud.com/typora/image-20220307145109028.png" alt="image-20220307145109028"></p><p>Step7 后台部署后根据阿里云外网IP+8080端口即可打开</p><p>相关问题汇总</p><p>后台某些页面提示500找不到jsp或403被禁止：停止tomcat服务，删除war包和展开的文件夹，删除work&#x2F;Catlina，重新上传部署</p><p><a href="https://www.freesion.com/article/8606758444/">在linux服务器部署web项目并成功访问（开启端口） - 灰信网（软件开发博客聚合）</a></p><p><a href="https://www.freesion.com/article/3569575843/">Linux系统的tomcat以daemon模式启动 - 灰信网（软件开发博客聚合）</a></p><p><a href="https://blog.csdn.net/zacry/article/details/103063001">Linux下非root用户运行Tomcat_zacry的专栏-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010648555/article/details/78073104">Linux服务器Tomcat中Catalina.log中定位错误信息方法_阿飞云-CSDN博客</a></p><p><a href="https://blog.csdn.net/ypp91zr/article/details/79279351">linux启动tomcat报错Invalid user name ‘tomcat’ specified_程序员-CSDN博客</a></p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>官网 | <a href="https://redis.io/download">Redis</a></p><p>Step1 下载并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://download.redis.io/releases/redis-5.0.14.tar.gz<br>tar -zxvf redis-5.0.14.tar.gz<br><span class="hljs-built_in">mv</span> redis-5.0.14 /usr/local/redis<br></code></pre></td></tr></table></figure><p>Step2 安装（参考<a href="https://blog.csdn.net/qq_39135287/article/details/83474865%EF%BC%89">https://blog.csdn.net/qq_39135287/article/details/83474865）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local/redis/ &amp;&amp; make<br><span class="hljs-built_in">cd</span> src/ &amp;&amp; make install<br><span class="hljs-comment"># 可能需要安装pkg-config</span><br>sudo apt-get install pkg-config<br></code></pre></td></tr></table></figure><p>Step3 修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/local/redis/redis.conf<br><br>修改以下内容<br><br><span class="hljs-comment"># 如果使用systemd配置开机启动则需要设置为no</span><br>daemonize <span class="hljs-built_in">yes</span> <br><br><span class="hljs-comment"># 外网访问需要注释bind并关闭保护模式。但在云服务器上暴露6379端口易被TeamTNT挖矿程序入侵，所以建议修改bind的IP为指定范围来取代注释</span><br><span class="hljs-comment"># bind 127.0.0.1</span><br>protected-mode no<br><br><span class="hljs-comment"># 设置日志位置</span><br>logfile <span class="hljs-string">&quot;/var/lib/redis/redis.log&quot;</span><br><br><span class="hljs-comment"># 设置dump.rdb快照位置，</span><br><span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;/var/lib/redis/&quot;</span><br><br><span class="hljs-comment"># 设置密码（找到下面一行并取消注释，替换foobared为密码）</span><br>requirepass foobared<br></code></pre></td></tr></table></figure><p>Step4 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动服务</span><br>redis-server redis.conf<br><span class="hljs-comment"># 连接测试 -h IP -p 端口 -a 密码</span><br>redis-cli [-h host -p 6379] -a password<br><span class="hljs-comment"># 关闭服务</span><br>redis-cli -a password shutdown<br></code></pre></td></tr></table></figure><p>Step5 配置服务及开机启动（Ubuntu）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 编辑文件<br>vim /lib/systemd/system/redisd.service<br><br>2. 写入服务配置<br>[Unit]<br>Description=Redis<br>After=syslog.target<br><br>[Service]<br>ExecStart=/usr/local/redis5/src/redis-server /usr/local/redis5/redis.conf<br>RestartSec=5s<br>Restart=on-success<br><br>[Install]<br>WantedBy=multi-user.targe<br><br>3. 设置开机启动（将/lib/systemd/system/redisd.service连接到/etc/systemd/system/redisd.service）<br>systemctl <span class="hljs-built_in">enable</span> redisd<br><br>4. 关闭开机启动<br>systemctl <span class="hljs-built_in">disable</span> redisd<br><br>5. 手动启动<br>systemctl start redisd<br><br>6. 查看状态<br>systemctl status redisd<br></code></pre></td></tr></table></figure><p>Step6 云服务器外网连接可参照Tomcat环境配置的Step4和Step6开启服务器和阿里云的防火墙端口</p><p>相关问题</p><p>编译报错 <code>jemalloc/jemalloc.h: No such file or directory</code></p><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc g++ make cmake<br>make distclean &amp;&amp; make<br></code></pre></td></tr></table></figure><p>参考连接</p><p><a href="https://blog.csdn.net/qq_39135287/article/details/83474865">Linux下安装Redis_浅末年华的博客-CSDN博客_linux安装redis</a></p><p><a href="https://gist.github.com/mkocikowski/aeca878d58d313e902bb">Setting up Redis to run as a daemon under systemd</a></p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 安装<br>sudo apt install mysql-server<br>2. 服务启动与停止<br>service mysql start<br>service mysql stop<br>3. 登录<br>mysql -u root -p[password]<br>4. 修改密码<br>use mysql;<br>update user <span class="hljs-built_in">set</span> plugin=<span class="hljs-string">&quot;mysql_native_password&quot;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;<br>update mysql.user <span class="hljs-built_in">set</span> authentication_string=password(<span class="hljs-string">&#x27;passd&#x27;</span>) <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;<br>flush privileges;<br>5. 从sql脚本中导入数据表<br>create database <span class="hljs-built_in">test</span>;<br>use <span class="hljs-built_in">test</span>;<br><span class="hljs-built_in">set</span> names utf8;<br><span class="hljs-built_in">source</span> /where/place/test.sql<br></code></pre></td></tr></table></figure><p>相关问题汇总</p><p><a href="https://blog.51cto.com/u_15082403/4349707">安装mysql服务器（windows版）_mb5ffd7010f3b33的技术博客_51CTO博客</a></p><p><a href="https://www.runoob.com/mysql/mysql-database-import.html">MySQL 导入数据 | 菜鸟教程</a></p><p><a href="https://blog.csdn.net/weixin_43424368/article/details/109600313">从输入任何密码都可以直接登录 MySQL 的 root 用户谈 auth_socket 验证插件—发表到爱可生开源社区_姚远的博客-CSDN博客</a></p><ul><li>WSL2安装mysql-server提示sock问题</li></ul><p><a href="https://juejin.cn/post/6961800061210591268">wsl2 安装 mysql 实战 - 掘金</a></p><ul><li>远程无法连接</li></ul><p><a href="https://blog.csdn.net/xuonline4196/article/details/88900301">MySQL 1130错误，无法远程连接_xuonline4196的博客-CSDN博客_mysql1130错误</a></p><p><a href="https://blog.csdn.net/weixin_43873714/article/details/105271405">阿里云服务器远程连接mysql出现10061错误_咸鱼翻不了身也是咸鱼的博客-CSDN博客_远程连接mysql报10061</a></p><p><a href="https://www.csdn.net/tags/MtTaEgwsMDQ2MDAtYmxvZwO0O0OO0O0O.html">mysql远程连接错误2013 - CSDN</a></p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Step1 下载并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://archive.apache.org/dist/kafka/0.10.2.0/kafka_2.11-0.10.2.0.tgz<br>tar -zxvf kafka_2.11-0.10.2.0.tgz<br><span class="hljs-built_in">mv</span> kafka_2.11-0.10.2.0 /usr/local/kafka<br></code></pre></td></tr></table></figure><p>Step2 修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改/usr/local/kafka/config/server.properties</span><br>delete.topic.enable=<span class="hljs-literal">true</span><br>auto.create.topics.enable=<span class="hljs-literal">false</span><br>listeners=PLAINTEXT://172.19.101.253:9092<br>advertised.listeners=PLAINTEXT://120.26.106.4:9092<br>zookeeper.connect=120.26.106.4:2181<br><br><span class="hljs-comment"># 修改/etc/profile</span><br><span class="hljs-built_in">export</span> KAFKA_HOME=/usr/local/kafka<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$&#123;KAFKA_HOME&#125;</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>Step3 相关指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先启动zookeeper（调用kafka/bin下的zookeeper）</span><br>zookeeper-server-start.sh -daemon /usr/local/kafka/config/zookeeper.properties<br><span class="hljs-comment"># 启动kafka</span><br><span class="hljs-built_in">nohup</span> kafka-server-start.sh /usr/local/kafka/config/server.properties 1&gt;/dev/null 2&gt;&amp;1 &amp;<br><span class="hljs-comment"># 创建topic</span><br>kafka-topics.sh --create --zookeeper 120.26.106.4:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 删除topic</span><br>kafka-topics.sh --delete --zookeeper 120.26.106.4:2181 --topic <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 生产消息</span><br>kafka-console-producer.sh --broker-list 120.26.106.4:9092 --topic <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 消费消息</span><br>kafka-console-consumer.sh --bootstrap-server 120.26.106.4:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure><p>Step4 配置Kafka和Zookeeper外网链接前要配置防火墙（同时还要在阿里云服务器安全组管理开放对应端口）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Zookeeper</span><br>firewall-cmd --zone=public --add-port=2181/tcp --permanent<br><span class="hljs-comment"># Kafka</span><br>firewall-cmd --zone=public --add-port=9092/tcp --permanent<br>firewall-cmd --reload<br>firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><p>相关问题汇总</p><p><a href="https://segmentfault.com/a/1190000019501252">linux 安装ZooKeeper - SegmentFault 思否</a></p><p><a href="https://www.chengzime.com.cn/articles/2020/04/16/1587032781131.html">Linux 安装 kafka - 程子的博客</a></p><p><a href="https://blog.csdn.net/DreamsArchitects/article/details/108331418">如何在阿里云服务器上配置部署kafka_DreamsArchitects的博客-CSDN博客_阿里云服务器部署kafka</a></p><p><a href="https://www.cnblogs.com/freedom-only/p/14257784.html">Java Kafka 简单示例 - lw007 - 博客园</a></p><p><a href="https://github.com/Stevenchooo/Kafka-SpringMVC">Stevenchooo&#x2F;Kafka-SpringMVC: SpringMVC and Kafka integration example</a></p><p><a href="https://blog.csdn.net/creepcheck/article/details/105926873">Solved - Spring Kafka consumer.poll()如何一次只获取一条消息？consumer.poll()后会移除Kafka队列中的消息吗？_creepcheck的博客-CSDN博客_kafka poll 一次</a></p><p><a href="https://blog.csdn.net/duzm200542901104/article/details/103888584">kafka不同的topic使用相同的group的问题_duzm200542901104的专栏-CSDN博客_kafka不同groupid</a></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>安装nginx，打包前台文件，并移动到nginx的dist文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打包vue前台</span><br>npm run build<br></code></pre></td></tr></table></figure><p>编辑nginx配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/local/nginx/conf/nginx.conf<br><br><span class="hljs-comment"># 修改server配置，映射到对应的静态页面</span><br>server &#123;<br>        listen       80;<br>        server_name  填域名;<br><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br><br>        location / &#123;<br>            root   dist;<br>            index  index.html;<br>        &#125;<br><br>        location /page/ &#123;<br>            proxy_redirect off;<br>            proxy_set_header Host <span class="hljs-variable">$host</span>;<br>            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            proxy_set_header X-Forwarded <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>            proxy_pass http://外网IP:8080;<br>        &#125;<br>        <br>error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>相关指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br>/usr/local/nginx/sbin/nginx <br><span class="hljs-comment"># 重启</span><br>/usr/local/nginx/sbin/nginx -s reload<br><span class="hljs-comment"># 关闭</span><br>/usr/local/nginx/sbin/nginx -s quit<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="EasyConnect"><a href="#EasyConnect" class="headerlink" title="EasyConnect"></a>EasyConnect</h4><p>Step1 下载地址 <a href="https://rvpn.zju.edu.cn/com/installClient.html#auto-common%EF%BC%8C%E9%80%89%E6%8B%A9EasyConnect_x64.deb%EF%BC%8C%E5%AE%89%E8%A3%85%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8">https://rvpn.zju.edu.cn/com/installClient.html#auto-common，选择EasyConnect_x64.deb，安装到云服务器</a></p><p>Step2 MobaXterm执行以下指令，在弹出的输入框输入vpn服务器地址和认证信息，登陆即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/sangfor/EasyConnect/EasyConnect<br></code></pre></td></tr></table></figure><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 生成ssh密钥<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your@email.com&quot;</span> -f path/rsa_name<br>2. 添加pub至github<br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br>3. 查看链接状态<br>ssh -T git@github.com<br>4. 设置用户名邮箱（全局）<br>git config --global user.name <span class="hljs-string">&quot;username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span><br>5. 出现git@github.com: Permission denied (publickey).<br>ssh-agent -s<br>ssh-add ~/.ssh/id_rsa <span class="hljs-comment"># 注意替换id_rsa为所使用的私钥路径，如果出错则运行 ssh-agent bash</span><br></code></pre></td></tr></table></figure><p>问题汇总：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">问题： git@github.com: Permission denied (publickey).<br>解决：修改 ~/.ssh/config, 添加<br><br>Host remoteIP<br>    HostName remoteDomain（远程域名）<br>    User user（远程用户名）<br>    IdentityFile ~/.ssh/xxx（私钥）<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GO111MODULE=on<br>go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><h4 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 执行安装脚本<br>sh Anaconda3-2022.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><h4 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 全局修改<br>pip config <span class="hljs-built_in">set</span> global.index-url https://mirrors.zju.edu.cn/pypi/simple<br>2. 单次使用<br>pip install -i https://mirrors.zju.edu.cn/pypi/simple some-package<br>3. 镜像源统计<br>浙江大学 https://mirrors.zju.edu.cn/pypi/simple<br>清华大学 https://pypi.tuna.tsinghua.edu.cn/simple<br>阿里云 http://mirrors.aliyun.com/pypi/simple/<br>豆瓣 https://pypi.doubanio.com/simple/<br>4. 查看当前源<br>pip config list<br></code></pre></td></tr></table></figure><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. vscode 远程登录<br>（本地）<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your@email.com&quot;</span> -f path/rsa_name<br>scp<br>（远程）<br><span class="hljs-built_in">cat</span> xxx.pub &gt;&gt; authorized_keys<br>（本地）<br>修改 ~/.ssh/config, 添加<br><br>Host remoteIP<br>    HostName remoteDomain（远程域名）<br>    User user（远程用户名）<br>    IdentityFile ~/.ssh/xxx（私钥）<br>例<br>Host github.com<br>    HostName github.com<br>    User aaaaa<br>    IdentityFile ~/.ssh/id_rsa<br><br></code></pre></td></tr></table></figure><h4 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 删除源<br>/etc/apt/sources.list<br>/etc/apt/sources.list.d/<br>2. 切换源<br>sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list<br><br>替换阿里源<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br><br><span class="hljs-comment"># deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>问题1：WSL2换源提示Ceritificate相关问题</p><p>(1) 修改sources.list中https为http</p><p>(2) apt-get update</p><p>(3) apt-get install ca-certificates</p><p>(4) 修改sources.list中http为https</p><h4 id="Wrk"><a href="#Wrk" class="headerlink" title="Wrk"></a>Wrk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 下载源码<br>git <span class="hljs-built_in">clone</span> https://github.com/wg/wrk.git<br>2. 切换到wrk目录并安装<br><span class="hljs-built_in">cd</span> wrk &amp;&amp; make<br>3. 拷贝wrk到程序目录<br><span class="hljs-built_in">cp</span> wrk /usr/bin<br></code></pre></td></tr></table></figure><h4 id="Rocketmq"><a href="#Rocketmq" class="headerlink" title="Rocketmq"></a>Rocketmq</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mqnamesrv.cmd<br>mqbroker.cmd -n localhost:9876<br></code></pre></td></tr></table></figure><p><a href="https://github.com/apache/rocketmq">apache&#x2F;rocketmq: Mirror of Apache RocketMQ</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java】HashMap源码阅读</title>
    <link href="/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="注释部分"><a href="#注释部分" class="headerlink" title="注释部分"></a>注释部分</h2><ol><li><p>HashMap比Hashtable相比，少了同步，多了对null key的支持。</p></li><li><p>假定元素在bucket中均匀分布的前提下，get和set是常数复杂度。迭代的性能取决于HashMap的容量，因此当迭代性能比较重要时要避免将初始容量设置过大（或load factor设置过低）。</p></li><li><p>HashMap的性能受初始容量和load factor影响。load factor定义了HashMap可容纳的元素数占容量的比例，当元素数超出load factor定义的可容纳数时，会触发rehash。</p></li><li><p>0.75的load factor很好的均衡了时间和空间损耗。更高的load factor提高了空间利用率，但也增加了哈希碰撞的几率，导致底层bin存储结构过于复杂，因此增加了查找的开销（包括get和put在内的大部分操作）。过小的load factor空间利用率过低。初始容量的设置需要考虑HashMap中目标存储元素数量及目标的load factor，当 目标存储元素数量&#x2F;load factor &lt; 初始容量 时，rehash操作就不会触发。</p></li><li><p>当多个key拥有相同的hashCode（）时会降低性能，当key是Comparable时可以通过比较key的顺序来打破？？</p></li><li><p>HashMap非同步，当多个线程同时访问HashMap且至少一个线程对HashMap做出了结构化的修改（add或delete一个或多个k-v对，但不包括更新一个已有的k-v对的value）。通常可以对HashMap进行封装，在封装的Object上加上同步锁来解决这一问题。或通过声明时使用Collections.synchronizedMap装饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Map</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(...));<br></code></pre></td></tr></table></figure></li><li><p>HashMap返回的所有迭代器都具有fail-fast的特性，当HashMap发生结构化改变时（不包括使用迭代器本身的remove方法），所有在改变前创建的迭代器都会失效并抛出ConcurrentModificationException异常。但需要注意的是，这一特性并没有严格的保证，因此要避免过分依赖这一特性，而是仅将其用作错误检测的手段。</p></li><li><p>HashMap正常情况下使用bin，当某个hash对应的k-v对过多时会将bin转为TreeMap，当由于删除操作导致Tree bin中元素减少到阈值时，该bin又会转回Plain bin。TreeMap通常使用hashCode排序，但当TreeMap中存储的元素类都实现了Comparable时（通过反射检测），TreeMap就会使用compareTo方法进行排序。当TreeMap存储的元素拥有不同的hashCode或是Comparable时，最差时间复杂度达到O(log n)。</p></li><li><p>bin node在plain和tree间转化时保持相对访问顺序。</p></li></ol><h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><ol><li><p>类定义：集成了AbstractMap，实现了Map、Cloneable、Serializable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure></li><li><p>默认参数定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始容量16（必须是2的倍数）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 默认load factor</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><span class="hljs-comment">// plain-&gt;tree转换的bin阈值</span><br><span class="hljs-comment">// bin长度为k时哈希碰撞概率为(exp(-0.5) * pow(0.5, k) * factorial(k))</span><br><span class="hljs-comment">// 当k=8时概率为0.00000006，小于千万分之一，是一个比较合适的长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// tree-&gt;plain转换的bin阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><span class="hljs-comment">// plain-&gt;tree转换的capicity阈值，只有容量大于此阈值时TREEIFY_THRESHOLD才适用</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure></li><li><p>节点定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<br>&#125;<br><span class="hljs-comment">// hashCode</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>&#125;<br><span class="hljs-comment">// equals</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>        <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>            Objects.equals(value, e.getValue()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>扰动函数，将完整hash的高位和地位做异或，增大随机性，变相保留高位信息</p><p><a href="https://www.cnblogs.com/zhengwang/p/8136164.html">https://www.cnblogs.com/zhengwang/p/8136164.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>扩容目标容量计算，目的是获得首位为0，后面后面全为1的值，该值+1进位得到2的幂次数即为大于等于目标容量的最小2幂次数。</p><p><a href="https://www.cnblogs.com/loading4/p/6239441.html">https://www.cnblogs.com/loading4/p/6239441.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存储hash bin</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><span class="hljs-comment">// HashMap实际存储量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br><span class="hljs-comment">// HashMap产生结构性变化的次数，包括rehash，主要用于iterator的fail-fast机制</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<br><span class="hljs-comment">// capacity * load factor，threshold初始值为大于initialCapacity的2的幂次</span><br><span class="hljs-type">int</span> threshold;<br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br></code></pre></td></tr></table></figure></li><li><p>初始化4种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传capacity，loadFactor</span><br><span class="hljs-comment">// 0&lt;=initialCapacity&lt;=MAXIMUM_CAPACITY</span><br><span class="hljs-comment">// loadFactor&gt;=0 且非 NaN</span><br><span class="hljs-comment">// threshold设为tableSizeFor(initialCapacity)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span>;<br><span class="hljs-comment">// 传capacity</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">// 默认</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><span class="hljs-comment">// 传另一个map</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HashMap合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// evict false-用于使用另一个map初始化HashMap，true-HashMap已初始化</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span>;<br><br></code></pre></td></tr></table></figure></li><li><p>HashMap插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Implements Map.put and related methods.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hash hash for key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to put</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> onlyIfAbsent 如果为 true, 不改变已有 value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict 如果为 false, 则table正处于创建模式.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 若key-value存在则返回之前的value, 否则返回null</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<span class="hljs-comment">// table非空时 n 在这里赋值</span><br>        n = (tab = resize()).length;<span class="hljs-comment">// table为空时，n赋值为table扩容后的大小</span><br>    <span class="hljs-comment">// HashMap的capacity总为2的幂次，在(n-1)&amp;hash时capacity作为掩码使用，用于取对应hash值在table中的位置</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<span class="hljs-comment">// p首次赋值，对应位置为空直接插入</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// s1 hash对应位置的key和要插入的key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// s1 || s2 key不相等且对应位置是Tree bin，直接调用TreeNode的插入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode) <br>            <span class="hljs-comment">// 如果在Tree中找到了对应的key，则返回该节点，否则创建并插入该节点，返回null</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// s1 || s3 key不相等且对应位置是Plain bin，遍历到List的最后一个位置插入，如果bin容量达到阈值-1？则将bin树化</span><br>        <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 处理s1的情况，如果onlyIfAbsent为true则不更新value，否则更新</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            <span class="hljs-comment">// 主要用于LinkedHashMap</span><br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果不是s1（新建Node并插入）时，需要将structed modify计数+1</span><br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 由于evict为true，因此当m和当前table包含的key相同时，putAll会替换所有当前key</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;putMapEntries(m, evict:<span class="hljs-literal">true</span>);&#125;<br></code></pre></td></tr></table></figure></li><li><p>HashMap查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据hash找到bin，在bin内部搜索key。找到则返回value，未找到返回null</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 根据hash找到bin，在bin内部搜索key。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span> &#123;<span class="hljs-keyword">return</span> getNode(hash(key), key) != <span class="hljs-literal">null</span>;&#125;<br><span class="hljs-comment">// 需要遍历整个HashMap来寻找value</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; V v;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                <span class="hljs-keyword">if</span> ((v = e.value) == value ||<br>                    (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HashMap扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已达最大容量不扩容</span><br><span class="hljs-comment">// 容量为空则扩容为默认初始容量</span><br><span class="hljs-comment">// 容量不为空则扩为2倍，但同时保证不大于最大容量</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 已达到最大容量，直接返回原table，不执行扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 未达最大容量，扩容为原来的2倍（同时要保证小于最大容量）</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 当原Capacity为0，threshold&gt;0??</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 原表Capacity和Threshold均为0则使用默认值初始化</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 扩容后重新将原表的数据全部插入到新表中，将新表的capacity-1做掩码，与原表元素的hash计算获得该元素在新表中的位置</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 这里应该和Plain bin是类似的操作，也是根据hash增加的首位将原bin拆分成hash首位为1和首位为0两部分</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br><span class="hljs-comment">// 这里oldCap二进制表示首位为1，后面全为0。</span><br>                        <span class="hljs-comment">// 用e.hash和oldCap求与其实是将oldCap对应位置的元素拆分成1+oldhash和0+oldhash两部分。</span><br>                        <span class="hljs-comment">// 主要是因为newCap的二进制位比oldCap多一位，e.hash在存储时的有效位也增加了一位。</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HashMap删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// matchValue-当设为true时，仅当参数中的value和table中key对应的value相同时才移除</span><br><span class="hljs-comment">// movable-删除时不移动其他节点？？？用于树节点删除</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value, <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, e; K k; V v;<br>        <span class="hljs-comment">// 根据bin的不同类型寻找到要删除的点，使用hash快速判断，使用key具体判断</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// node为要删除的节点，p为node的前一个节点</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode) <span class="hljs-comment">// 删除节点为树节点</span><br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p) <span class="hljs-comment">// 删除节点为bin头节点，直接替换</span><br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 删除节点为plain节点</span><br>                p.next = node.next;<br>            <span class="hljs-comment">// 结构性改变计数+1</span><br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 清空所有节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    Node&lt;K,V&gt;[] tab;<br>    modCount++; <span class="hljs-comment">// 可以看出modCount并不是对应具体几个节点改变，只是记录导致结构改变的操作次数</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123;<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tab.length; ++i)<br>            tab[i] = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Bin的树化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 保留Plain Node顺序的同时，将所有Plain Node替换成TreeNode，保持原顺序首尾相连。最后调用treeify？</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HashMap中的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// KeySet和Values分别为HashMap中所有key和所有value的集合，对KeySet/Values的修改会映射到HashMap上，反之亦然。</span><br><span class="hljs-comment">// KeySet和Values支持遍历、查找和删除，不支持添加</span><br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;K&gt;;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Values</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;V&gt;;<br>    <br><span class="hljs-comment">// Key-Value对的集合，只支持对Key-Value节点的遍历、查找和删除</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntrySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt;;<br></code></pre></td></tr></table></figure></li><li><p>HashMap重写Map的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">getOrDefault</span><span class="hljs-params">(Object key, V defaultValue)</span>; <span class="hljs-comment">// 根据key查value，不存在则返回默认值</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">putIfAbsent</span><span class="hljs-params">(K key, V value)</span>; <span class="hljs-comment">// 若key不存在则插入</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key, Object value)</span>; <span class="hljs-comment">// 根据key-value删除</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span>; <span class="hljs-comment">// 如果key-value为指定值则替换</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">replace</span><span class="hljs-params">(K key, V value)</span>; <span class="hljs-comment">// key存在则替换value</span><br><span class="hljs-comment">// key对应的value为null，则根据key计算value并插入</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">computeIfAbsent</span><span class="hljs-params">(K key, Function&lt;? <span class="hljs-built_in">super</span> K, ? extends V&gt; mappingFunction)</span>;<br><span class="hljs-comment">// key对应的value存在，则根据key、oldValue计算newValue并更新</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">computeIfPresent</span><span class="hljs-params">(K key, BiFunction&lt;? <span class="hljs-built_in">super</span> K, ? <span class="hljs-built_in">super</span> V, ? extends V&gt; remappingFunction)</span>;<br><span class="hljs-comment">// 只根据oldValue计算newValue并更新</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">(K key, BiFunction&lt;? <span class="hljs-built_in">super</span> K, ? <span class="hljs-built_in">super</span> V, ? extends V&gt; remappingFunction)</span>;<br><span class="hljs-comment">// 根据oldValue和newValue计算一个value并更新</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">merge</span><span class="hljs-params">(K key, V value, BiFunction&lt;? <span class="hljs-built_in">super</span> V, ? <span class="hljs-built_in">super</span> V, ? extends V&gt; remappingFunction)</span>;<br><span class="hljs-comment">// 迭代所有Node执行action</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> K, ? <span class="hljs-built_in">super</span> V&gt; action)</span>;<br><span class="hljs-comment">// 使用function根据key-value计算新value并替换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> K, ? <span class="hljs-built_in">super</span> V, ? extends V&gt; function)</span>;<br></code></pre></td></tr></table></figure></li><li><p>HashMap序列化和反序列化</p><p><a href="https://blog.csdn.net/weixin_34308389/article/details/92079559">https://blog.csdn.net/weixin_34308389/article/details/92079559</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 序列化，写capacity、size以及所有entry的key和value，使用transient修饰的字段（包括table、size、modCount）不序列化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span>;<br><span class="hljs-comment">// 反序列化，分别反序列化key和value并执行putVal插入</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span>;<br></code></pre></td></tr></table></figure></li><li><p>HashMap迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基本迭代器</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;<br>    Node&lt;K,V&gt; next;        <span class="hljs-comment">// 当前key-value对</span><br>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// 下一个entry</span><br>    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// 记录iterator创建时的modCount，和HashMap的modCount比较来确定是否fail-fast</span><br>    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// 当前bin的下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;K,V&gt; p = current;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        current = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> p.key;<br>        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 调用迭代器的remove时会自动更新modCount，因此不会触发fail-fast</span><br>        expectedModCount = modCount;<br>    &#125;    <br>&#125;<br><span class="hljs-comment">// 三种实现，分别完成对key、value和entry的迭代</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;K&gt;;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;V&gt;;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt;;<br><br><span class="hljs-comment">// Split迭代器：并行迭代器？？</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapSpliterator</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> HashMap&lt;K,V&gt; map;<br>    Node&lt;K,V&gt; current;          <span class="hljs-comment">// current node</span><br>    <span class="hljs-type">int</span> index;                  <span class="hljs-comment">// current index, modified on advance/split</span><br>    <span class="hljs-type">int</span> fence;                  <span class="hljs-comment">// one past last index</span><br>    <span class="hljs-type">int</span> est;                    <span class="hljs-comment">// size estimate</span><br>    <span class="hljs-type">int</span> expectedModCount;       <span class="hljs-comment">// for comodification checks</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>TreeNode定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-type">boolean</span> red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>待补充</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识框架</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识框架</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【从零开始的Hexo博客搭建】功能完善</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA4%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA4%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84/</url>
    
    <content type="html"><![CDATA[<p>完成博客的基本构建和美化之后，接下来需要在功能方面做一些完善。</p><h2 id="添加标签、分类页面"><a href="#添加标签、分类页面" class="headerlink" title="添加标签、分类页面"></a>添加标签、分类页面</h2><p>首先需要新建页面，在根目录下分别执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page tags<br>$ hexo new page categories<br></code></pre></td></tr></table></figure><p>进入根目录下的 <code>source</code> 文件夹可以看到生成了两个新文件夹 <code>categories</code> 和 <code>tags</code> 分别进行编辑 <code>index.md</code> 文件，修改为对应类型</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">source/tags/index.md</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-02-12 10:17:59</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;tags&quot;</span><br><span class="hljs-string">source/categories/index.md</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">分类</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-02-12 10:18:38</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;categories&quot;</span><br></code></pre></td></tr></table></figure><p>修改完毕后打开<code>主题配置文件</code>，修改<code>menu</code>部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">/</span> <span class="hljs-string">||</span> <span class="hljs-string">home</span><br>  <span class="hljs-attr">archives:</span> <span class="hljs-string">/archives/</span> <span class="hljs-string">||</span> <span class="hljs-string">archive</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">/categories/</span> <span class="hljs-string">||</span> <span class="hljs-string">th</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">/tags/</span> <span class="hljs-string">||</span> <span class="hljs-string">tags</span><br>  <span class="hljs-comment">#about: /about/ || user </span><br>  <span class="hljs-comment">#schedule: /schedule/ || calendar</span><br>  <span class="hljs-comment">#sitemap: /sitemap.xml || sitemap</span><br>  <span class="hljs-comment">#commonweal: /404/ || heartbeat</span><br><br><span class="hljs-comment"># Enable/Disable menu icons.</span><br><span class="hljs-attr">menu_icons:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>去掉前方注释即可打开对应页面，修改关键字顺序即可改变对应页面在<code>menu</code>中的顺序</p><p>下方的<code>menu_icons</code>代表是否开启<code>menu</code>中标签左侧的图标</p><h2 id="添加侧边栏社交连接"><a href="#添加侧边栏社交连接" class="headerlink" title="添加侧边栏社交连接"></a>添加侧边栏社交连接</h2><p>修改<code>主题配置文件</code>中的<code>social</code>部分和<code>social_icons</code>部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">social:</span><br>  <span class="hljs-attr">GitHub:</span> <span class="hljs-string">https://github.com/medl2008</span> <span class="hljs-string">||</span> <span class="hljs-string">github</span><br>  <span class="hljs-attr">CSDN:</span> <span class="hljs-string">https://blog.csdn.net/StarEight</span><br><span class="hljs-attr">social_icons:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">icons_only:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">transition:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>Next 主题默认采用 <a href="https://fontawesome.com/icons?d=gallery&m=free">Font Awesome</a> 图标，其中<code>social</code>部分网址后的字段代表图标对应的名称</p><h2 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h2><p>详见<a href="http://theme-next.iissnan.com/third-party-services.html#search-system">官方教程</a></p><ol><li><p>首先进入 <a href="https://www.algolia.com/">Algolia</a> 官网，注册账号后进入 <code>Dashboard</code> ，然后通过左侧的 <code>Indices</code> 创建一个新的 <code>index</code> 。</p></li><li><p>安装<code>Algolia</code> 拓展，在博客根目录右键打开GitBash并执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save hexo-algolia<br></code></pre></td></tr></table></figure></li><li><p>在 Algolia 服务站点上找到需要使用的一些配置的值，包括 <code>ApplicationID</code>、<code>Search-Only API Key</code>、 <code>Admin API Key</code>。注意，<code>Admin API Key</code> 需要保密保存。点击<code>ALL API KEYS</code> 找到新建INDEX对应的key， 编辑权限，在弹出框中找到<code>ACL</code>选择勾选<code>addObject</code>, <code>deleteObject</code>, <code>listIndexes</code>, <code>deleteIndex</code>权限，点击<code>update</code>更新。</p><p>执行完毕后打开根目录下的<code>站点配置文件</code> ，新增配置如下（注意替换<code>applicationID</code>和<code>indexName</code>对应内容）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">algolia:</span><br>  <span class="hljs-attr">applicationID:</span> <span class="hljs-string">&#x27;applicationID&#x27;</span><br>  <span class="hljs-attr">apiKey:</span> <span class="hljs-string">&#x27;API Key&#x27;</span><br>  <span class="hljs-attr">indexName:</span> <span class="hljs-string">&#x27;indexName&#x27;</span><br>  <span class="hljs-attr">chunkSize:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p>我做到这里时遇到了一个问题，按官方文档教程做完后发现点击搜索没有反应，参考网上教程后加上了 apiKey 字段，最终解决问题。</p></li><li><p>当配置完成，在站点根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span>(windows为 <span class="hljs-built_in">set</span>) HEXO_ALGOLIA_INDEXING_KEY=Search-Only API key<br>$ hexo algolia<br></code></pre></td></tr></table></figure><p>这里要注意，如果使用Git Bash的话第一条指令仍是export，同时还要注意将第一条指令的<code>Search-Only API key</code> 替换成对应的值</p><p>第二条指令作用是更新 <code>Algolia</code> 标签，当新建或修改文章时均需要执行 <code>hexo algolia</code></p></li><li><p>更改<code>主题配置文件</code> ，修改Algolia Search配置部分，将 enable 改为 true</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Algolia Search</span><br><span class="hljs-attr">algolia_search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hits:</span><br>    <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">input_placeholder:</span> <span class="hljs-string">Search</span> <span class="hljs-string">for</span> <span class="hljs-string">Posts</span><br>    <span class="hljs-attr">hits_empty:</span> <span class="hljs-string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span><br>    <span class="hljs-attr">hits_stats:</span> <span class="hljs-string">&quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span><br></code></pre></td></tr></table></figure><p>label 部分可根据需要更改</p></li></ol><h2 id="添加文章版权信息"><a href="#添加文章版权信息" class="headerlink" title="添加文章版权信息"></a>添加文章版权信息</h2><p>编辑<code>主题配置文件</code>，修改 <code>post_copyright</code> 部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Declare license on posts</span><br><span class="hljs-attr">post_copyright:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">license:</span> <span class="hljs-string">CC</span> <span class="hljs-string">BY-NC-SA</span> <span class="hljs-number">3.0</span><br>  <span class="hljs-attr">license_url:</span> <span class="hljs-string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br></code></pre></td></tr></table></figure><h2 id="添加字数统计"><a href="#添加字数统计" class="headerlink" title="添加字数统计"></a>添加字数统计</h2><p>安装统计插件，在博客根目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm i --save hexo-wordcount<br></code></pre></td></tr></table></figure><p>编辑<code>主题配置文件</code> ，修改 <code>post_wordcount</code> 部分，将wordcount属性设为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_wordcount:</span><br>  <span class="hljs-attr">item_text:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">wordcount:</span> <span class="hljs-literal">true</span>       <span class="hljs-comment"># 单篇字数统计</span><br>  <span class="hljs-attr">min2read:</span> <span class="hljs-literal">true</span>        <span class="hljs-comment"># 单篇阅读时常估计</span><br>  <span class="hljs-attr">totalcount:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment"># 网站总字数统计</span><br>  <span class="hljs-attr">separated_meta:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>增加显示文字，用文本编辑器打开<code>themes/next/layout/_macro/post.swig</code> ，定位到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;&#123; __(&#x27;post.wordcount&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    &#123;&#123; wordcount(post.content) &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;&#123; __(&#x27;post.wordcount&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>&#123;&#123; wordcount(post.content) &#125;&#125; 字<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定位到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;&#123; __(&#x27;post.min2read&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>&#123;&#123; min2read(post.content) &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;&#123; __(&#x27;post.min2read&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    &#123;&#123; min2read(post.content) &#125;&#125; min<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="添加访客量文章阅读量统计"><a href="#添加访客量文章阅读量统计" class="headerlink" title="添加访客量文章阅读量统计"></a>添加访客量文章阅读量统计</h2><p>使用 Next 主题集成的不蒜子统计，编辑<code>主题配置文件</code> ，修改<code>busuanzi_count</code>部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">busuanzi_count:</span><br>  <span class="hljs-comment"># count values only if the other configs are false</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 站点访客数</span><br>  <span class="hljs-attr">site_uv:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">site_uv_header:</span> <span class="hljs-string">&lt;i</span> <span class="hljs-string">class=&quot;fa</span> <span class="hljs-string">fa-user&quot;&gt;&amp;nbsp;&amp;nbsp;本站访客数&lt;/i&gt;</span><br>  <span class="hljs-attr">site_uv_footer:</span> <span class="hljs-string">人</span><br>  <span class="hljs-comment"># 站点访问次数</span><br>  <span class="hljs-attr">site_pv:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">site_pv_header:</span> <span class="hljs-string">&lt;i</span> <span class="hljs-string">class=&quot;fa</span> <span class="hljs-string">fa-eye&quot;&gt;&lt;/i&gt;</span><br>  <span class="hljs-attr">site_pv_footer:</span><br>  <span class="hljs-comment"># 页面阅读次数</span><br>  <span class="hljs-attr">page_pv:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">page_pv_header:</span> <span class="hljs-string">&lt;i</span> <span class="hljs-string">class=&quot;fa</span> <span class="hljs-string">fa-file-o&quot;&gt;&amp;nbsp;&amp;nbsp;本文阅读量&lt;/i&gt;</span><br>  <span class="hljs-attr">page_pv_footer:</span> <span class="hljs-string">次</span><br></code></pre></td></tr></table></figure><p>此时直接部署会发现访客数无法显示，这是因为Next内置的<a href="http://busuanzi.ibruce.info/">卜算子统计</a>域名已经过期了，需要进行修改，编辑 <code>/theme/next/layout/_third-party/analytics/busuanzi-counter.swig</code></p><p>修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后部署即可（本地显示访问人数可能有异常）</p><h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><ol><li>采用 valine 评论系统，具体步骤如下</li><li>注册 Leancloud 账号 <a href="https://leancloud.cn/">官网地址</a></li><li>进入控制台，新建一个应用，名字任意</li><li>进入新创建的应用，点击 <code>设置→应用 Key</code> ，复制 <code>App ID</code> 和 <code>App Key</code></li><li>点击 <code>设置→安全中心</code> ，在<code>Web安全域名</code>一栏填入网站的域名</li><li>打开<code>主题配置文件</code>，定位到 <code>valine</code> ，将<code>enable</code>设为<code>true</code>，并将<code>appid</code>和<code>appkey</code>填入</li><li>部署完成后即可在文章下方看到评论区</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1f8107a8778c">hexo搭建个人博客–NexT主题优化</a></p><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414">为你的Hexo加上评论系统-Valine</a></p><p><a href="https://www.cnblogs.com/php-linux/p/8418518.html">Hexo添加字数统计、阅读时长</a></p><p><a href="https://www.jianshu.com/p/fd3accaa2ae0">hexo博客解决不蒜子统计无法显示问题</a></p><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414">为你的Hexo加上评论系统-Valine</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【从零开始的Hexo博客搭建】主题美化</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA3%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA3%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/themes/">Hexo 官方主题预览</a></p><p>Hexo 官方主页上提供了很多主题，这里我选择了比较流行的 <a href="http://theme-next.iissnan.com/">Next 主题</a>，以下内容皆基于 Next 主题。</p><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>在博客根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure><p>如果会用魔法的话可以尝试以下指令启用代理加快下载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global http.proxy socks5://127.0.0.1:1080 <br>$ git config --global https.proxy socks5://127.0.0.1:1080<br></code></pre></td></tr></table></figure><p>停用代理使用以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global http.proxy <span class="hljs-string">&quot;&quot;</span><br>$ git config --global https.proxy <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>编辑根目录下的 _<code>config.yml</code> 文件，定位到 <code>theme</code> 字段，将其修改为 <code>next</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>打开网页即可看到改变后的主题（如果没有变化可以尝试使用 <code>Ctrl+F5</code> 强制刷新）</p><h2 id="美化主题"><a href="#美化主题" class="headerlink" title="美化主题"></a>美化主题</h2><p>这里主要修改两个 <code>_config.yml</code> 文件，一个位于根目录下，称为<code>站点配置文件</code>，另一个位于 <code>themes/next</code> 下，成为<code>主题配置文件</code></p><h3 id="修改博客信息"><a href="#修改博客信息" class="headerlink" title="修改博客信息"></a>修改博客信息</h3><p>首先修改<code>站点配置文件</code>的 <code>Site</code> 部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo</span><span class="hljs-comment"># 标题</span><br><span class="hljs-attr">subtitle:</span><br><span class="hljs-attr">description:</span><span class="hljs-comment"># 用于搜索引擎检索（可选）</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span><span class="hljs-comment"># 网站作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-comment"># 语言，修改为 zh-Hans</span><br><span class="hljs-attr">timezone:</span><br></code></pre></td></tr></table></figure><h3 id="修改主题类型"><a href="#修改主题类型" class="headerlink" title="修改主题类型"></a>修改主题类型</h3><p>Next 提供了四种风格的主题，在<code>主题配置文件</code>去掉对应注释即可更改为对应主题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Schemes</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">Muse</span><br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-comment">#scheme: Pisces</span><br><span class="hljs-comment">#scheme: Gemini</span><br></code></pre></td></tr></table></figure><h3 id="修改脚标"><a href="#修改脚标" class="headerlink" title="修改脚标"></a>修改脚标</h3><p>默认情况下博客网页下方有许多不必要的信息，可以通过修改<code>站点配置文件</code>中的<code>footer</code>部分进行自行定义要显示的内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># Specify the date when the site was setup.</span><br>  <span class="hljs-comment"># If not defined, current year will be used.</span><br>  <span class="hljs-comment">#since: 2015</span><br><br>  <span class="hljs-comment"># Icon between year and copyright info.</span><br>  <span class="hljs-attr">icon:</span> <span class="hljs-string">copyright</span><br><br>  <span class="hljs-comment"># If not defined, will be used `author` from Hexo main config.</span><br>  <span class="hljs-attr">copyright:</span><br>  <span class="hljs-comment"># -------------------------------------------------------------</span><br>  <span class="hljs-comment"># Hexo link (Powered by Hexo).</span><br>  <span class="hljs-attr">powered:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">theme:</span><br>    <span class="hljs-comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># Version info of NexT after scheme info (vX.X.X).</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># -------------------------------------------------------------</span><br>  <span class="hljs-comment"># Any custom text can be defined here.</span><br>  <span class="hljs-comment">#custom_text: Hosted by &lt;a target=&quot;_blank&quot; href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;</span><br></code></pre></td></tr></table></figure><h3 id="显示浏览百分比"><a href="#显示浏览百分比" class="headerlink" title="显示浏览百分比"></a>显示浏览百分比</h3><p>编辑<code>主题配置文件</code>，将<code>scrollpercent</code>设为<code>true</code></p><h3 id="修改头像"><a href="#修改头像" class="headerlink" title="修改头像"></a>修改头像</h3><p>将要替换的头像放在 <code>themes/next/source/images</code> 下，修改<code>主题配置文件</code>的<code>Sidebar Avatar</code>部分启用对应头像</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Sidebar Avatar</span><br><span class="hljs-comment"># in theme directory(source/images): /images/avatar.gif</span><br><span class="hljs-comment"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="hljs-attr">avatar:</span> <span class="hljs-string">/images/avatar.gif</span><br></code></pre></td></tr></table></figure><h3 id="设置主页文章自动折叠"><a href="#设置主页文章自动折叠" class="headerlink" title="设置主页文章自动折叠"></a>设置主页文章自动折叠</h3><p>编辑<code>主题配置文件</code>，定位到<code>auto_excerpt</code>字段并设<code>enable</code>为<code>true</code></p><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><p>将图标图片放在<code>themes\next\source\images</code>下，编辑<code>主题配置文件</code>，修改<code>favicon</code>字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">favicon:</span><br>  <span class="hljs-attr">small:</span> <span class="hljs-string">/images/logo.ico</span><br>  <span class="hljs-attr">medium:</span> <span class="hljs-string">/images/logo.ico</span><br>  <span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/images/logo.ico</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【从零开始的Hexo博客搭建】文章发布</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>完成了基本的框架搭建后，就可以发布文章了。Hexo支持Markdown格式，可以在本地使用特定的编辑器来编写（比如 <a href="https://www.typora.io/">Typora</a>）。下面简单记录一下步骤。</p><h2 id="文章创建和发布"><a href="#文章创建和发布" class="headerlink" title="文章创建和发布"></a>文章创建和发布</h2><p>在博客根目录下右键打开 Git Bash ，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;文章题目&quot;</span><br></code></pre></td></tr></table></figure><p>输入后可以在 <code>source/_posts</code>文件夹下发现新建好的 <code>md</code> 文件，使用编辑器打开，开头的部分是 yaml 配置部分，<code>title</code> 代表文章的标题，<code>date</code> 代表文章的创建日期，<code>tags</code> 代表文章的标签， <code>categories</code> 代表文章的分类。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">hello-world</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-02-11 10:20:36</span><br><span class="hljs-attr">tags:</span> <br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>对其进行更改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">hello-world</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-02-11 10:20:36</span><br><span class="hljs-attr">tags:</span> <span class="hljs-string">Hexo</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">技术</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>编辑完成并保存后，在博客根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>发布完成后即可在网站旁边看到对应的标签和分类。</p><h2 id="关于文章中插入数学公式"><a href="#关于文章中插入数学公式" class="headerlink" title="关于文章中插入数学公式"></a>关于文章中插入数学公式</h2><p><a href="https://www.jianshu.com/p/7ab21c7f0674">参考教程</a></p><p>博客根目录下运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><p>在主题配置文件中开启mathjax开关</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">math:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># Default (true) will load mathjax / katex script on demand.</span><br>  <span class="hljs-comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span><br>  <span class="hljs-comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># See: https://mhchem.github.io/MathJax-mhchem/</span><br>    <span class="hljs-attr">mhchem:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在文章的Front-matter中打开mathjax开关</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: index.html<br>date: 2016-12-28 21:01:30<br>tags:<br><span class="hljs-section">mathjax: true</span><br><span class="hljs-section">--</span><br></code></pre></td></tr></table></figure><h2 id="关于文章中插入图片"><a href="#关于文章中插入图片" class="headerlink" title="关于文章中插入图片"></a>关于文章中插入图片</h2><h3 id="方法一：本地"><a href="#方法一：本地" class="headerlink" title="方法一：本地"></a>方法一：本地</h3><p><a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705">参考教程</a></p><p>参考了以上链接中的文章，主要步骤总结如下：</p><ol><li><p>用编辑器打开博客根目录下的 _<code>config.yml</code> 文件，定位到 <code>post_asset_folder</code> ，将其设为 <code>true</code></p></li><li><p>在博客根目录右键打开Git Bash，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p>这时如果使用 <code>hexo new</code> 新建一篇文章，在 <code>source/_posts</code> 文件夹下会同时生成 <code>.md</code> 文件和与其同名的空文件夹，把要用到的图片放到文件夹中，然后就可以使用 <code>Markdown</code> 格式引入图片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">你想输入的替代文字</span>](<span class="hljs-link">xxxx/图片名.jpg</span>)<br></code></pre></td></tr></table></figure><p>其中 xxxx 替换为空文件夹的名字，比如说创建一篇题为 Hello-world 的文章，其中引用了 1.jpg，那么格式就是</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">你想输入的替代文字</span>](<span class="hljs-link">Hello-world/1.jpg</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="方法二：图床"><a href="#方法二：图床" class="headerlink" title="方法二：图床"></a>方法二：图床</h3><ol><li><p>上传图片到图床（SM.MS、路过图床等），获取到url链接</p></li><li><p>在markdown中替换图片对应链接</p></li></ol><h2 id="关于-Markdown-语法"><a href="#关于-Markdown-语法" class="headerlink" title="关于 Markdown 语法"></a>关于 Markdown 语法</h2><p>这方面网上教程比较多，提供两篇参考</p><p><a href="http://www.cnblogs.com/hnrainll/p/3514637.html">参考1</a></p><p><a href="https://www.jianshu.com/p/191d1e21f7ed">参考2</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【从零开始的Hexo博客搭建】框架搭建</title>
    <link href="/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <url>/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>寒假在家无聊就想着搭个博客玩玩，经过一番考察之后最终选择了Hexo+GitHub Pages的方案，写这篇文章的目的主要是记录一下搭建过程，方便以后参考。由于涉及到的内容比较多，所以分成几个部分来写。第一部分就写一下如何搭建Hexo博客的框架并且发布到GitHub Pages。</p><h2 id="创建-GitHub-项目"><a href="#创建-GitHub-项目" class="headerlink" title="创建 GitHub 项目"></a>创建 GitHub 项目</h2><p>在 Github 上创建名为 <code>user.github.io</code> 的项目，<code>user</code>替换成你的 Github 用户名</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <a href="https://www.git-scm.com/download/">Git</a></h2><p>命令提示符中输入 <code>git --version</code> 检验是否安装成功</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 <a href="https://nodejs.org/en/">Node.js</a></h2><p>命令提示符中输入 <code>node -v</code> 和 <code>npm -v</code> 检验是否安装成功</p><h2 id="安装-Hexo框架"><a href="#安装-Hexo框架" class="headerlink" title="安装 Hexo框架"></a>安装 <a href="https://hexo.io/zh-cn/">Hexo框架</a></h2><p>首先在要保存博客的位置右键打开Git Bash，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>安装完成后可用 <code>hexo -v</code> 验证是否安装成功，然后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init Blog<br></code></pre></td></tr></table></figure><p>执行完毕后会在<strong>执行位置</strong>生成名为 <code>Blog</code> 的文件夹，该文件夹即为博客的根目录</p><h2 id="将-Git-连接到-GitHub"><a href="#将-Git-连接到-GitHub" class="headerlink" title="将 Git 连接到 GitHub"></a>将 Git 连接到 GitHub</h2><p>首先将 Git 连接到 Github <a href="https://segmentfault.com/a/1190000007466317">Git连接Github教程</a> </p><p>安装git支持插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后在博客根目录下编辑 _<code>config.yml</code> 文件，定位到 <code>deploy</code> 部分后按如下格式修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:medl2008/medl2008.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p><code>repo</code> 的部分网上有很多教程采用的是 <code>http</code> 的方式，但是我在实际操作过程中遇到了一些问题，所以最终采用上面的方法解决问题。</p><p>这里还需要注意<code>yml</code>格式的配置文件在所有参数的冒号后要有一个<strong>空格</strong>，否则无法正确识别。</p><h2 id="预览博客并发布到-Github"><a href="#预览博客并发布到-Github" class="headerlink" title="预览博客并发布到 Github"></a>预览博客并发布到 Github</h2><p>首先简单介绍一下几个指令，具体可见<a href="https://hexo.io/zh-cn/docs/commands.html">官方文档</a></p><ul><li><strong>hexo g</strong> - 生成博客静态文件</li><li><strong>hexo s</strong> - 启动本地服务器</li><li><strong>hexo d</strong> - 部署网站</li><li><strong>hexo clean</strong> - 清除缓存和已生成的静态文件</li></ul><p>在博客根目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>此时打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 可以看到博客预览</p><p>要将博客同步到 Github 需要下载插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>下载完成后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>然后打开 <code>user.github.io</code> 就可看到博客了，至此博客框架搭建完成。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
